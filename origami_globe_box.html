<!--
/**
 * 360 Image DEEP HACK Equi2Poly3
 * 
 * @description 360ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ã‚’å¤šé¢ä½“ã«å¤‰æ›ï¼‰
 * @author asari keisuke
 * @license Public Domain - å†é…å¸ƒã€æ”¹å¤‰è‡ªç”±ã€ä¸€åˆ‡ã®åˆ¶é™ãªã—
 * @disclaimer 
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 *   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DAMAGES ARISING FROM THE USE OF THIS SOFTWARE.
 *   ã“ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ç„¡ä¿è¨¼ã§æä¾›ã•ã‚Œã€ä½œè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
 *   - ãƒ¡ãƒ¢ãƒªä¸è¶³ã«ã‚ˆã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
 *   - å‡¦ç†çµæœã®å“è³ªã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“
 *   - é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã¯äº‹å‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ãã ã•ã„
 *   - æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½¿ç”¨ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™
 *
 * æœ¬ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ JSZip (https://stuk.github.io/jszip/)(MIT License) ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™
 * 
 * ----- CHANGELOG --------------------------------------------------------------------------------
 * v 1.0 ãƒªãƒªãƒ¼ã‚¹
 * v 1.1 æ­£äºŒåé¢ä½“ã®å„é¢ã®å½¢çŠ¶ã‚’ä¿®æ­£ï¼ˆï¼‰
 * Acknowledgements
 * æ­£äºŒåé¢ä½“ã®å„é¢å½¢çŠ¶ã®æ¤œè¨¼ãƒ»æ”¹å–„ã«å”åŠ›ã„ãŸã ã„ãŸ asari ã•ã‚“ã«æ„Ÿè¬ã—ã¾ã™ ğŸ™
 *
 * v 1.2 ãƒ©ãƒ³ã‚¿ã‚¤ãƒ åè»¢ã¨ä¸Šä¸‹é¢ã®å‘ãèª¿æ•´ã€å±•é–‹ç·šæç”»ã€ZIP/ã‚¿ã‚¤ãƒ«å¼·åŒ–ï¼ˆ2025-09-06ï¼‰
 *  - [å¤‰æ›å…ƒã®æ‰±ã„] å¤‰æ›å®Ÿè¡Œæ™‚ã«ã ã‘å‡¦ç†åˆ†å²ã€‚æ­£å…­é¢ä½“ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ãã®ã¾ã¾ä½¿ç”¨ã€‚
 *     æ­£äºŒåé¢ä½“ / åˆ‡é ‚äºŒåé¢ä½“ã¯ã€å®Ÿè¡Œç›´å‰ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ã€Œæ°´å¹³åè»¢ã€ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã§ç½®æ›ã€‚
 *     (createHorizontallyFlippedCanvas, originalImageã®å°å…¥ã§å‰¯ä½œç”¨ã‚’å›é¿)
 *  - [ãƒã‚°ä¿®æ­£] fileé¸æŠã§èª­ã¿è¾¼ã‚“ã å ´åˆã«ã‚‚ originalImage ã‚’ç¢ºå®Ÿã«ã‚»ãƒƒãƒˆï¼ˆD&Dã¨æŒ™å‹•ã‚’çµ±ä¸€ï¼‰ã€‚
 *  - [ç´™ã®å±•é–‹å›³å‘ã‘] æ­£å…­é¢ä½“ã®ä¸Šä¸‹é¢ã®å‡ºåŠ›ã‚’å°åˆ·çµ„ã¿ç«‹ã¦ç”¨ã«æœ€é©åŒ–ã€‚
 *       poly_ny(-Y).png : å·¦å³åè»¢ â†’ æ™‚è¨ˆå›ã‚Šã«90Â°å›è»¢
 *       poly_py(+Y).png : å·¦å³åè»¢ â†’ åæ™‚è¨ˆå›ã‚Šã«90Â°å›è»¢
 *     (flipHThenRotate90 ã‚’ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã§é©ç”¨ã€‚ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¼ã¯æœªå¤‰æ›´)
 *  - [æ–°æ©Ÿèƒ½] ã€Œå±•é–‹ç·šã‚’ã‚¨ã‚¯ã‚¤ç”»åƒã«æãã€å‡ºåŠ›ã‚’è¿½åŠ ï¼ˆè‰²/å¤ªã•æŒ‡å®šå¯ï¼‰ã€‚
 *     å¤šé¢ä½“ã®å…¨ã‚¨ãƒƒã‚¸ã‚’çƒé¢è£œé–“ã§ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã€çµŒåº¦ã¾ãŸãã‚’è€ƒæ…®ã—ã¦equirectã«æç”»ãƒ»ä¿å­˜ã€‚
 *  - [å‡ºåŠ›å¼·åŒ–] ç”Ÿæˆé¢ã®ä¸€æ‹¬ZIPä¿å­˜(JSZip)ï¼1æšã‚¿ã‚¤ãƒ«ç”Ÿæˆã¨ä¿å­˜ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä»˜ãï¼‰ã‚’æ•´å‚™ã€‚
 *  - [UI/å¾®ä¿®æ­£] å“è³ªãƒ©ãƒ™ãƒ«ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã€ã‚¢ãƒ©ãƒ¼ãƒˆæ–‡è¨€èª¿æ•´ã€å†…éƒ¨é–¢æ•°ã®æ•´ç†ã€‚
 * ã“ã“ã¾ã§ã€https://github.com/ikejun360go/360onWeb/ ã®20250906ç‰ˆ(ver.1.2)
 *
 * ã“ã“ã‹ã‚‰ã€asari360jp/360appsã¨ã—ã¦ã®ä¿®æ­£
 * ver.20250927 æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®è¿½åŠ 
 * ver.20250929 æ­£å››é¢ä½“ã®è¿½åŠ 
 * ver.20250930 æ­£å…«é¢ä½“ã®è¿½åŠ  https://github.com/ikejun360go/360onWeb/ ã‚ˆã‚Š20250927ç‰ˆ(ver.1.3)ã‚’ãƒãƒ¼ã‚¸
 * ver.20251001 æ­£åäºŒé¢ä½“ã®è¿½åŠ 
 * ver.20251028 æ­£å››é¢ä½“,æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã§å¤‰æ›å‰ã®ç”»åƒåè»¢ãªã—ã‚’æ˜ç¤º(æ“ä½œé †ã«ã‚ˆã£ã¦ç”»åƒåè»¢ã—ã¦ã—ã¾ã†ãƒã‚°ä¿®æ­£)
 * ------------------------------------------------------------------------------------------------
 *
 * æ—¢çŸ¥ã®æ³¨æ„:
 *  - å¤§å®¹é‡ç”»åƒã§ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¢—ãˆã¾ã™ã€‚ä¿å­˜å‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã‚µã‚¤ã‚ºã‚’ã”ç¢ºèªãã ã•ã„ã€‚
 *  - equirectã®æ¥µä»˜è¿‘ã§ã¯ç”»ç´ å¯†åº¦ã®é–¢ä¿‚ã§ã«ã˜ã¿ãŒè¦‹ãˆã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼ˆä»•æ§˜ï¼‰ã€‚
 *
 * ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ:
 *  - Base Code & Design: ã„ã‘ã ã˜ã‚…ã‚“ã˜ (https://github.com/ikejun360go/360onWeb/)
 *  - Enhanced with: Claude / ChatGPT / Grokï¼ˆå®Ÿè£…ææ¡ˆãƒ»ãƒã‚°ä¿®æ­£ãƒ»æœ€é©åŒ–ï¼‰
 *  - Third-party: JSZip (MIT)
 */
-->

<!DOCTYPE html>
<html lang="ja">
<head>
<!-- è¿½åŠ ï¼šZIPç”Ÿæˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Equirectangular to Polyhedron Exporter</title>
<style>
  :root{
    --bg1:#1e3c72; --bg2:#2a5298;
    --panel: rgba(255,255,255,0.1);
    --accent:#4CAF50;
  }
  body{
    margin:0; padding:20px; color:#fff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    background:linear-gradient(135deg,var(--bg1),var(--bg2));
  }
  .container{ max-width:1200px; margin:0 auto; }
  h1{ margin:0 0 12px; font-size:22px; }
  .row{ display:grid; gap:12px; grid-template-columns: 1fr; }
  @media(min-width:900px){ .row{ grid-template-columns: 1fr 1fr; } }
  .card{
    background:var(--panel); border:1px solid rgba(255,255,255,0.2);
    border-radius:16px; padding:16px; backdrop-filter: blur(8px);
  }
  label{ display:block; font-size:14px; opacity:0.9; margin-bottom:6px; }
  input[type="number"], select, input[type="text"]{
    width:100%; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.25);
    background:rgba(0,0,0,0.2); color:#fff; outline:none;
  }
  .range-row{ display:flex; align-items:center; gap:8px; }
  input[type="range"]{ flex:1; }
  .btn{
    background:var(--accent); border:none; color:#fff; padding:10px 16px; border-radius:12px; cursor:pointer;
    font-weight:600; box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  }
  .btn.secondary{ background:#2196F3; }
  .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.35); }
  .upload-area{
    border:2px dashed var(--accent); border-radius:12px; padding:14px; text-align:center;
    background:rgba(255,255,255,0.08);
  }
  .upload-area.dragover{ border-color:#2196F3; background:rgba(255,255,255,0.12); }
  .faces{
    display:flex; flex-wrap:wrap; gap:16px; align-items:flex-start;
  }
  .face{
    background:rgba(0,0,0,0.2); border-radius:12px; padding:10px; text-align:center; border:1px solid rgba(255,255,255,0.15);
  }
  .face canvas{ display:block; max-width:256px; height:auto; border-radius:8px; }
  .face p{ margin:8px 0 8px; font-size:12px; opacity:0.9; }
  .grid-preview{ max-width:100%; border-radius:12px; }
  .mini{ font-size:12px; opacity:0.85; }
  .split{ display:flex; gap:10px; flex-wrap:wrap; }
</style>
</head>
<body>
<div class="container">
  <h1>360ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ â†’ å¤šé¢ä½“ã€€å¤‰æ›</h1>

  <div class="row">
    <!-- å…¥åŠ› -->
    <div class="card">
      <h2 style="margin-top:0;font-size:18px;">1) å…¥åŠ›</h2>
      <div class="upload-area" id="uploadArea">
        <p class="mini">ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ— / ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰é¸æŠ</p>
        <input type="file" id="fileInput" accept="image/*" />
      </div>
      <div id="inputInfo" class="mini" style="margin-top:8px; opacity:.8;">æœªèª­ã¿è¾¼ã¿</div>
    </div>

    <!-- è¨­å®š -->
    <div class="card">
      <h2 style="margin-top:0;font-size:18px;">2) è¨­å®š</h2>
      <div class="split">
        <div style="flex:1; min-width:220px;">
          <label>å¤šé¢ä½“ã®ç¨®é¡</label>
          <select id="polyType">
            <option value="tetrahedron">æ­£å››é¢ä½“ï¼ˆ4ä¸‰è§’ï¼‰</option>
            <option value="cube">æ­£å…­é¢ä½“ï¼ˆ6æ­£æ–¹ï¼‰</option>
            <option value="octa">æ­£å…«é¢ä½“ï¼ˆ8ä¸‰è§’ï¼‰</option>
            <option value="dodecahedron">æ­£åäºŒé¢ä½“ï¼ˆ12äº”è§’ï¼‰</option>
            <option value="icosa">æ­£äºŒåé¢ä½“ï¼ˆ20ä¸‰è§’ï¼‰</option>
            <option value="truncated">åˆ‡é ‚äºŒåé¢ä½“ï¼ˆ12äº”è§’+20å…­è§’ï¼‰</option>
            <option value="rhombicubocta">æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼ˆ8ä¸‰è§’+18æ­£æ–¹ï¼‰</option>
          </select>
        </div>
        <div style="flex:1; min-width:220px;">
          <label>é¢ã‚µã‚¤ã‚ºï¼ˆæ¨å¥¨ï¼šã‚­ãƒ¥ãƒ¼ãƒ–=å¹…/4ã€äºŒåé¢/åˆ‡é ‚=å¹…/6ã€œ/8ï¼‰</label>
          <input type="number" id="faceSize" min="64" max="4096" step="1" value="512" />
        </div>
      </div>

      <div id="truncRow" style="margin-top:10px; display:none;">
        <label>åˆ‡é ‚ç‡ tï¼ˆ0.25ã€œ0.4 ãŒå®Ÿç”¨ï¼‰</label>
        <div class="range-row">
          <input type="range" id="truncRange" min="0.20" max="0.45" step="0.005" value="0.333" />
          <input type="number" id="truncNumber" min="0.20" max="0.45" step="0.001" value="0.333" style="width:100px;" />
        </div>
      </div>

      <div style="margin-top:14px;">
        <button class="btn" id="runBtn">å¤‰æ›ã‚’å®Ÿè¡Œ</button>
        <button class="btn ghost" id="clearBtn">ã‚¯ãƒªã‚¢</button>
      </div>
    </div>
  </div>

  <!-- å‡ºåŠ› -->
  <div class="card" style="margin-top:14px;">
    <h2 style="margin-top:0;font-size:18px;">3) å‡ºåŠ›å½¢å¼</h2>
    <div class="split">
      <div style="flex:1; min-width:220px;">
        <label>ä¿å­˜å½¢å¼</label>
        <select id="fmt">
          <option value="image/png">PNGï¼ˆå¯é€†ï¼‰</option>
          <option value="image/jpeg">JPEGï¼ˆéå¯é€†ï¼‰</option>
          <option value="image/webp">WebPï¼ˆãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œæ™‚ï¼‰</option>
        </select>
      </div>
      <div style="flex:1; min-width:220px;">
        <label>å“è³ªï¼ˆJPEG/WebPã®ã¿æœ‰åŠ¹ï¼‰</label>
        <div class="range-row">
          <input type="range" id="qualityRange" min="0.5" max="1" value="0.92" step="0.01" />
          <span id="qualityLabel" class="mini">0.92</span>
        </div>
      </div>
      <div style="flex:1; min-width:220px;">
        <label>å‡ºåŠ›åãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹</label>
        <input type="text" id="prefix" value="poly_" />
      </div>
    </div>

    <div style="margin-top:12px;">
      <button class="btn secondary" id="dlAllBtn">é¢ã‚’ä¸€æ‹¬ZIPä¿å­˜</button>
      <button class="btn" id="gridBtn">1æšã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆ</button>
      <button class="btn" id="layoutBtn">å±•é–‹å›³ã‚’ä½œæˆ</button>
      <a id="gridDownload" class="btn ghost" style="display:none;">ã‚¿ã‚¤ãƒ«ç”»åƒã‚’ä¿å­˜</a>
      <a id="layoutDownload" class="btn ghost" style="display:none;">å±•é–‹å›³ã‚’ä¿å­˜</a>
      <div id="gridInfo" class="mini" style="margin-top:8px; opacity:.85;"></div>
      <div id="layoutInfo" class="mini" style="margin-top:8px; opacity:.85;"></div>
    </div>
    
    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
  <button class="btn ghost" id="drawGuideBtn">å±•é–‹ç·šã‚’ã‚¨ã‚¯ã‚¤ç”»åƒã«æã</button>
  <label class="mini" style="margin:0;">è‰² <input type="color" id="guideColor" value="#ff2d55" style="vertical-align:middle;"></label>
  <label class="mini" style="margin:0;">å¤ªã•(px) <input type="number" id="guideWidth" value="2" min="1" max="8" step="1" style="width:70px;vertical-align:middle;"></label>
</div>

    
  </div>
  
  

  <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
  <div class="card" style="margin-top:14px;">
    <h2 style="margin-top:0;font-size:18px;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
    <div id="faces" class="faces"></div>
    <div id="gridWrap" style="margin-top:16px; display:none;">
      <p class="mini">ã‚¿ã‚¤ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼š</p>
      <canvas id="gridCanvas" class="grid-preview"></canvas>
    </div>
    <div id="layoutWrap" style="margin-top:16px; display:none;">
      <p class="mini">å±•é–‹å›³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼š</p>
      <canvas id="layoutCanvas" class="grid-preview"></canvas>
    </div>
  </div>
</div>

<script>
/* ============================= å…±æœ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ============================= */
// cubeã®ç‰¹å®šã«äºŒé¢ãŒä¿®æ­£ã®ãŸã‚è¿½åŠ  20250906+
// æ°´å¹³åè»¢ã—ã¦ã‹ã‚‰90åº¦å›è»¢ï¼ˆdir: 'cw' | 'ccw'ï¼‰
function flipHThenRotate90(srcCanvas, dir='cw'){
  const w = srcCanvas.width, h = srcCanvas.height; // æ­£æ–¹å½¢å‰æ
  // 1) æ°´å¹³åè»¢
  const flipped = document.createElement('canvas');
  flipped.width = w; flipped.height = h;
  const fctx = flipped.getContext('2d');
  fctx.translate(w, 0);
  fctx.scale(-1, 1);
  fctx.drawImage(srcCanvas, 0, 0);

  // 2) 90åº¦å›è»¢
  const out = document.createElement('canvas');
  out.width = w; out.height = h; // æ­£æ–¹å½¢ãªã®ã§åŒã˜
  const octx = out.getContext('2d');
  if (dir === 'cw'){          // æ™‚è¨ˆå›ã‚Š
    octx.translate(w, 0);
    octx.rotate(Math.PI / 2);
  } else {                    // åæ™‚è¨ˆå›ã‚Š
    octx.translate(0, h);
    octx.rotate(-Math.PI / 2);
  }
  octx.drawImage(flipped, 0, 0);
  return out;
}

// æ°´å¹³åè»¢ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è¿”ã™ï¼ˆimg/canvas ã©ã¡ã‚‰ã§ã‚‚OKï¼‰ 20250906+ for å¤šé‡é¢ä½“ã§ã®åè»¢ã®ãŸã‚
function createHorizontallyFlippedCanvas(img){
  const c = document.createElement('canvas');
  c.width = img.width; c.height = img.height;
  const ctx = c.getContext('2d');
  ctx.translate(c.width, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0);
  return c; // width/heightã‚’æŒã¤ã®ã§æ—¢å­˜ã®å‡¦ç†ã«ãã®ã¾ã¾æ¸¡ã›ã‚‹
}


function dirToLonLat(x,y,z){
  const r = Math.hypot(x,y,z);
  const lat = Math.asin(y / r);
  const lon = Math.atan2(x, z);
  return {lat, lon};
}

// ãƒãƒªã‚»ãƒ³åˆ¤å®šï¼šå†…éƒ¨ãªã‚‰ {inside:true,u,v,w} ã‚’è¿”ã™ï¼ˆæ­£äºŒåé¢ä½“æç”»ã§ä½¿ç”¨ï¼‰
function pointInTri(px, py, ax, ay, bx, by, cx, cy){
  const v0x = cx - ax, v0y = cy - ay;
  const v1x = bx - ax, v1y = by - ay;
  const v2x = px - ax, v2y = py - ay;
  const den = v0x*v1y - v1x*v0y;
  const u = (v2x*v1y - v1x*v2y) / den;
  const v = (v0x*v2y - v2x*v0y) / den;
  const w = 1 - u - v;
  const inside = (u >= 0 && v >= 0 && w >= 0);
  return {inside, u, v, w};
}

// 3Dä¸‰é ‚ç‚¹ã®ç·šå½¢â†’æ­£è¦åŒ–ï¼ˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«å–å¾—ï¼‰
function baryToDir(u,v,w, A,B,C){
  const x = u*A[0] + v*B[0] + w*C[0];
  const y = u*A[1] + v*B[1] + w*C[1];
  const z = u*A[2] + v*B[2] + w*C[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

// ã‚¨ã‚¯ã‚¤ç”»åƒã‹ã‚‰åŒç·šå½¢ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆçµŒåº¦ãƒ©ãƒƒãƒ—ãƒ»ç·¯åº¦ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
function bilinearInterpolateEquirect(eData, x, y, w, h){
  x = ((x % w) + w) % w;
  y = Math.max(0, Math.min(h - 1, y));

  const x0 = Math.floor(x), x1 = (x0 + 1) % w;
  const y0 = Math.floor(y), y1 = Math.min(h - 1, y0 + 1);
  const dx = x - x0, dy = y - y0;

  const idx = (xx,yy)=> (yy*w + xx) * 4;

  const i00 = idx(x0,y0), i10 = idx(x1,y0), i01 = idx(x0,y1), i11 = idx(x1,y1);
  const c00 = [eData[i00], eData[i00+1], eData[i00+2], eData[i00+3]];
  const c10 = [eData[i10], eData[i10+1], eData[i10+2], eData[i10+3]];
  const c01 = [eData[i01], eData[i01+1], eData[i01+2], eData[i01+3]];
  const c11 = [eData[i11], eData[i11+1], eData[i11+2], eData[i11+3]];

  const c0 = c00.map((v,i)=> v*(1-dx) + c10[i]*dx);
  const c1 = c01.map((v,i)=> v*(1-dx) + c11[i]*dx);
  const c  = c0.map((v,i)=> v*(1-dy) + c1[i]*dy);
  return c;
}

// 2Dãƒãƒªã‚´ãƒ³ã®å¹³å‡è¾ºé•·ï¼ˆéš£æ¥ç‚¹è·é›¢ã®å¹³å‡ï¼‰
function avgEdgeLen2D(poly2){
  let s = 0;
  for(let i=0;i<poly2.length;i++){
    const a = poly2[i], b = poly2[(i+1)%poly2.length];
    s += Math.hypot(b[0]-a[0], b[1]-a[1]);
  }
  return s / poly2.length;
}


/* ============================= æ­£å…«é¢ä½“ ============================= */
function octahedronData(){
  // æ­£å…«é¢ä½“ã®é ‚ç‚¹ï¼ˆÂ±1è»¸æ–¹å‘ï¼‰
  const V = [
    [ 1, 0, 0], [-1, 0, 0],  // Â±X
    [ 0, 1, 0], [ 0,-1, 0],  // Â±Y  
    [ 0, 0, 1], [ 0, 0,-1]   // Â±Z
  ];
  
  // æ­£å…«é¢ä½“ã®8ã¤ã®ä¸‰è§’é¢
  const F = [
    [0,2,4], [0,4,3], [0,3,5], [0,5,2],  // +Xé ‚ç‚¹ã‚’å«ã‚€4é¢
    [1,4,2], [1,3,4], [1,5,3], [1,2,5]   // -Xé ‚ç‚¹ã‚’å«ã‚€4é¢
  ];
  
  return {V, F};
}

function convertEquirectToOctahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const equirectData = tctx.getImageData(0, 0, ew, eh).data;

  const {V,F} = octahedronData();
  const faces = [];
  F.forEach((tri, i)=>{
    const A = V[tri[0]], B = V[tri[1]], C = V[tri[2]];
    const canvas = renderIcosaFace(equirectData, ew, eh, A,B,C, faceSize);
    faces.push({ name:`oct_${i}`, canvas });
  });
  return faces;
}

/* ============================= æ­£äºŒåé¢ä½“ ============================= */
function icosahedronData(){
  const PHI = (1 + Math.sqrt(5)) / 2;
  const V = [
    [-1,  PHI, 0], [ 1,  PHI, 0], [-1, -PHI, 0], [ 1, -PHI, 0],
    [ 0, -1,  PHI], [ 0,  1,  PHI], [ 0, -1, -PHI], [ 0,  1, -PHI],
    [ PHI, 0, -1], [ PHI, 0,  1], [-PHI, 0, -1], [-PHI, 0,  1],
  ].map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  const F = [
    [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
    [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
    [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
    [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1],
  ];
  return {V,F};
}

/* ============================= æ­£å››é¢ä½“ ============================= */
function tetrahedronData(){
  // æ­£å››é¢ä½“ã®4é ‚ç‚¹
  // ç«‹æ–¹ä½“ã®é ‚ç‚¹ã‚’åˆ©ç”¨ã—ãŸæ¨™æº–çš„ãªé…ç½®
  const vertices = [
    [ 1,  1,  1],
    [ 1, -1, -1],
    [-1,  1, -1],
    [-1, -1,  1]
  ];
  
  // æ­£è¦åŒ–
  const V = vertices.map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  
  // 4ã¤ã®ä¸‰è§’å½¢é¢ï¼ˆå¤–å‘ãæ³•ç·šã‚’è€ƒæ…®ã—ãŸé ‚ç‚¹é †åºï¼‰
  const F = [
    [0, 2, 1],  // é¢0
    [0, 3, 2],  // é¢1
    [0, 1, 3],  // é¢2
    [1, 2, 3]   // é¢3
  ];
  
  return {V, F};
}

/* ============================= æ­£åäºŒé¢ä½“ ============================= */
function dodecahedronData(){
  const PHI = (1 + Math.sqrt(5)) / 2;  // é»„é‡‘æ¯”
  const INV_PHI = 1 / PHI;              // 1/Ï†
  
  // æ­£åäºŒé¢ä½“ã®20é ‚ç‚¹
  const vertices = [
    // ç«‹æ–¹ä½“ã®é ‚ç‚¹ï¼ˆ8å€‹ï¼‰
    [ 1,  1,  1], [ 1,  1, -1], [ 1, -1,  1], [ 1, -1, -1],
    [-1,  1,  1], [-1,  1, -1], [-1, -1,  1], [-1, -1, -1],
    // é»„é‡‘é•·æ–¹å½¢ã®é ‚ç‚¹ï¼ˆ12å€‹ï¼‰
    [0,  INV_PHI,  PHI], [0,  INV_PHI, -PHI], [0, -INV_PHI,  PHI], [0, -INV_PHI, -PHI],
    [ INV_PHI,  PHI, 0], [ INV_PHI, -PHI, 0], [-INV_PHI,  PHI, 0], [-INV_PHI, -PHI, 0],
    [ PHI, 0,  INV_PHI], [ PHI, 0, -INV_PHI], [-PHI, 0,  INV_PHI], [-PHI, 0, -INV_PHI]
  ];
  
  // æ­£è¦åŒ–
  const V = vertices.map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  
  // 12å€‹ã®äº”è§’å½¢é¢ï¼ˆå¤–å‘ãæ³•ç·šã‚’è€ƒæ…®ã—ãŸé ‚ç‚¹é †åºï¼‰
  const F = [
    [0, 8, 10, 2, 16],    // é¢0
    [0, 12, 14, 4, 8],    // é¢1
    [0, 16, 17, 1, 12],   // é¢2
    [1, 17, 3, 11, 9],    // é¢3
    [1, 9, 5, 14, 12],    // é¢4
    [2, 10, 6, 15, 13],   // é¢5
    [2, 13, 3, 17, 16],   // é¢6
    [3, 13, 15, 7, 11],   // é¢7
    [4, 14, 5, 19, 18],   // é¢8
    [4, 18, 6, 10, 8],    // é¢9
    [5, 9, 11, 7, 19],    // é¢10
    [6, 18, 19, 7, 15]    // é¢11
  ];
  
  return {V, F};
}

/* ============================= æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ ============================= */
function rhombicuboctahedronData(){
  // æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®24é ‚ç‚¹ï¼ˆã‚ˆã‚Šæ­£ç¢ºãªåº§æ¨™ï¼‰
  const a = Math.sqrt(2) / 2.0; // ä¸€è¾ºã®åŠåˆ†
  const b = a + 1.0;
  
  const vertices = [
    // å‰å¾Œ(zè»¸æ–¹å‘)ã®é ‚ç‚¹
    [ a,  a,  b], [ a, -a,  b], [-a,  a,  b], [-a, -a,  b], // 0-3
    [ a,  a, -b], [ a, -a, -b], [-a,  a, -b], [-a, -a, -b], // 4-7
    // ä¸Šä¸‹(yè»¸æ–¹å‘)ã®é ‚ç‚¹
    [ a,  b,  a], [ a,  b, -a], [-a,  b,  a], [-a,  b, -a], // 8-11
    [ a, -b,  a], [ a, -b, -a], [-a, -b,  a], [-a, -b, -a], // 12-15
    // å·¦å³(xè»¸æ–¹å‘)ã®é ‚ç‚¹
    [ b,  a,  a], [ b,  a, -a], [ b, -a,  a], [ b, -a, -a], // 16-19
    [-b,  a,  a], [-b,  a, -a], [-b, -a,  a], [-b, -a, -a]  // 20-23
  ];
  
  // æ­£è¦åŒ–
  const V = vertices.map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  
  // ä¸‰è§’å½¢é¢ï¼ˆ8å€‹ï¼‰ - æ­£å…«é¢ä½“ã®é¢ã«å¯¾å¿œ
  const triangles = [
    [0, 8, 16], [1, 18, 12], [2, 20, 10], [3, 14, 22],	// tri_00, tri_01, tri_02, tri_03
    [4, 17, 9], [5, 13, 19], [6, 11, 21], [7, 23, 15]	// tri_04, tri_05, tri_06, tri_07
  ];
  
  // æ­£æ–¹å½¢é¢ï¼ˆ18å€‹ï¼‰ - ç«‹æ–¹ä½“ã®é¢ã‚’åˆ‡ã‚Šå–ã£ãŸå½¢
  const squares = [
    [0, 2, 10, 8], [3, 1, 12, 14], [6, 4, 9, 11], [5, 7, 15, 13],	// sq_00, sq_01, sq_02, sq_03
    [1, 0, 16, 18], [2, 3, 22, 20], [4, 5, 19, 17], [21, 23, 7, 6],	// sq_04, sq_05, sq_06, sq_07
    [0, 1, 3, 2], [6, 7, 5, 4], [13, 12, 18, 19], [22, 14, 15, 23],	// sq_08, sq_09, sq_11, sq_12
    [8, 10, 11, 9], [14, 12, 13, 15], [16, 17, 19, 18], 	// sq_12, sq_13, sq_14
    [21, 20, 22, 23], [8, 9, 17, 16], [11, 10, 20, 21]		// sq_15, sq_16, sq_17
  ];
  
  return {V, triangles, squares};
}

function renderIcosaFace(equirectData, ew, eh, A, B, C, faceSize){
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  // æ­£ä¸‰è§’å½¢ï¼ˆside=faceSizeï¼‰ã‚’æ­£æ–¹å½¢ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã«å†…æ¥ã•ã›ã‚‹
  const side = faceSize;
  const h = side * Math.sqrt(3) / 2;               // æ­£ä¸‰è§’å½¢ã®é«˜ã•
  const marginY = Math.max(0, (faceSize - h) / 2); // å‚ç›´æ–¹å‘ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°

  // é ‚ç‚¹åº§æ¨™ï¼ˆä¸Šï¼šAã€ä¸‹å·¦ï¼šBã€ä¸‹å³ï¼šCï¼‰
  const ax = faceSize / 2,        ay = marginY;
  const bx = (faceSize - side) / 2, by = marginY + h;
  const cx = (faceSize + side) / 2, cy = marginY + h;


  for(let py=0; py<faceSize; py++){
    for(let px=0; px<faceSize; px++){
      const {inside,u,v,w} = pointInTri(px+0.5, py+0.5, ax,ay, bx,by, cx,cy);
      if(!inside) continue;

      const [dx,dy,dz] = baryToDir(u,v,w, A,B,C);
      const {lat, lon} = dirToLonLat(dx,dy,dz);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      const c = bilinearInterpolateEquirect(equirectData, ex, ey, ew, eh);

      const idx = (py*faceSize + px)*4;
      data[idx  ] = c[0];
      data[idx+1] = c[1];
      data[idx+2] = c[2];
      data[idx+3] = c[3];
    }
  }
  ctx.putImageData(img,0,0);
  return canvas;
}

function convertEquirectToIcosahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const equirectData = tctx.getImageData(0, 0, ew, eh).data;

  const {V,F} = icosahedronData();
  const faces = [];
  F.forEach((tri, i)=>{
    const A = V[tri[0]], B = V[tri[1]], C = V[tri[2]];
    const canvas = renderIcosaFace(equirectData, ew, eh, A,B,C, faceSize);
    faces.push({ name:`tri_${i}`, canvas });
  });
  return faces;
}

/* ============================= åˆ‡é ‚äºŒåé¢ä½“ï¼ˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼‰ ============================= */
function edgeKey(a,b){ return (a<b) ? `${a}_${b}` : `${b}_${a}`; }

function slerpLikeNormalize(A,B,t){
  const x = (1-t)*A[0] + t*B[0];
  const y = (1-t)*A[1] + t*B[1];
  const z = (1-t)*A[2] + t*B[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

function cross(X,Y){ return [X[1]*Y[2]-X[2]*Y[1], X[2]*Y[0]-X[0]*Y[2], X[0]*Y[1]-X[1]*Y[0]]; }
function add(X,Y){ return [X[0]+Y[0], X[1]+Y[1], X[2]+Y[2]]; }

function truncatedIcosahedronData(t=1/3){
  const {V,F} = icosahedronData();

  // å…¨ã‚¨ãƒƒã‚¸åé›†
  const edgeMap = new Map();
  F.forEach((tri, fi)=>{
    for(let k=0;k<3;k++){
      const a = tri[k], b = tri[(k+1)%3];
      const key = edgeKey(a,b);
      if(!edgeMap.has(key)) edgeMap.set(key, {a: Math.min(a,b), b: Math.max(a,b), faces: new Set()});
      edgeMap.get(key).faces.add(fi);
    }
  });

  // ç«¯ç‚¹å´åˆ‡é ‚ç‚¹ï¼ˆæœ‰å‘ï¼‰
  const Epoints = new Map();
  edgeMap.forEach(({a,b})=>{
    const A = V[a], B = V[b];
    Epoints.set(`${a}_${b}`, slerpLikeNormalize(A,B,t));
    Epoints.set(`${b}_${a}`, slerpLikeNormalize(B,A,t));
  });

  // äº”è§’ï¼šå„å…ƒé ‚ç‚¹aã®å‘¨ã‚Šï¼ˆ12æšï¼‰
  const pentagons = [];
  for(let a=0; a<V.length; a++){
    const connected = [];
    edgeMap.forEach(({a:ea,b:eb})=>{
      if(ea===a) connected.push(eb);
      else if(eb===a) connected.push(ea);
    });
    const pts = connected.map(b => Epoints.get(`${a}_${b}`));
    const n = V[a];
    const tmp = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
    // u = normalize(tmp Ã— n)
    let ux = tmp[1]*n[2] - tmp[2]*n[1];
    let uy = tmp[2]*n[0] - tmp[0]*n[2];
    let uz = tmp[0]*n[1] - tmp[1]*n[0];
    let invu = 1/Math.hypot(ux,uy,uz);
    const u = [ux*invu, uy*invu, uz*invu];
    // v = n Ã— u
    const vx = n[1]*u[2] - n[2]*u[1];
    const vy = n[2]*u[0] - n[0]*u[2];
    const vz = n[0]*u[1] - n[1]*u[0];
    const v = [vx,vy,vz];

    const withAng = pts.map(p=>{
      const ang = Math.atan2( p[0]*v[0]+p[1]*v[1]+p[2]*v[2], p[0]*u[0]+p[1]*u[1]+p[2]*u[2] );
      return {p, ang};
    }).sort((a,b)=>a.ang-b.ang);

    pentagons.push(withAng.map(o=>o.p));
  }

  // å…­è§’ï¼šå„å…ƒä¸‰è§’é¢ï¼ˆ20æšï¼‰
  const hexagons = [];
  F.forEach(([a,b,c])=>{
    const Pab = Epoints.get(`${a}_${b}`);
    const Pba = Epoints.get(`${b}_${a}`);
    const Pbc = Epoints.get(`${b}_${c}`);
    const Pcb = Epoints.get(`${c}_${b}`);
    const Pca = Epoints.get(`${c}_${a}`);
    const Pac = Epoints.get(`${a}_${c}`);

    const A=V[a], B=V[b], C=V[c];
    let n = add(add(cross(A,B), cross(B,C)), cross(C,A));
    const inv = 1/Math.hypot(n[0],n[1],n[2]); n = [n[0]*inv, n[1]*inv, n[2]*inv];

    const tmp = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
    let ux = tmp[1]*n[2] - tmp[2]*n[1];
    let uy = tmp[2]*n[0] - tmp[0]*n[2];
    let uz = tmp[0]*n[1] - tmp[1]*n[0];
    let invu = 1/Math.hypot(ux,uy,uz);
    const u = [ux*invu, uy*invu, uz*invu];
    const vx = n[1]*u[2] - n[2]*u[1];
    const vy = n[2]*u[0] - n[0]*u[2];
    const vz = n[0]*u[1] - n[1]*u[0];
    const v = [vx,vy,vz];

    const pts = [Pab,Pba,Pbc,Pcb,Pca,Pac];
    const withAng = pts.map(p=>{
      const ang = Math.atan2( p[0]*v[0]+p[1]*v[1]+p[2]*v[2], p[0]*u[0]+p[1]*u[1]+p[2]*u[2] );
      return {p, ang};
    }).sort((a,b)=>a.ang-b.ang);

    hexagons.push(withAng.map(o=>o.p));
  });

  return { pentagons, hexagons };
}

/* ============================= é¢å¹³é¢ãƒ™ãƒ¼ã‚¹ã®æç”»ï¼ˆæŠ•å½±ï¼‰ ============================= */
// é¢æ³•ç·šï¼ˆNewellé¢¨ï¼‰
function faceNormalOfPolygon(poly3D){
  let nx=0, ny=0, nz=0;
  const n = poly3D.length;
  for(let i=0;i<n;i++){
    const a = poly3D[i];
    const b = poly3D[(i+1)%n];
    nx += a[1]*b[2]-a[2]*b[1];
    ny += a[2]*b[0]-a[0]*b[2];
    nz += a[0]*b[1]-a[1]*b[0];
  }
  const inv = 1/Math.hypot(nx,ny,nz);
  return [nx*inv, ny*inv, nz*inv];
}

// nã«ç›´äº¤ã™ã‚‹åŸºåº•(u,v)
function basisUVfromNormal(n){
  const t = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
  let ux = t[1]*n[2]-t[2]*n[1];
  let uy = t[2]*n[0]-t[0]*n[2];
  let uz = t[0]*n[1]-t[1]*n[0];
  const invu = 1/Math.hypot(ux,uy,uz);
  const u=[ux*invu, uy*invu, uz*invu];
  const vx = n[1]*u[2]-n[2]*u[1];
  const vy = n[2]*u[0]-n[0]*u[2];
  const vz = n[0]*u[1]-n[1]*u[0];
  const v=[vx,vy,vz];
  return {u,v};
}

// 3Dé ‚ç‚¹åˆ—ã‚’(u,v)å¹³é¢ã¸æ­£å°„å½±
function projectPolyToPlane2D(poly3D, u, v){
  return poly3D.map(p=> [ p[0]*u[0]+p[1]*u[1]+p[2]*u[2],
                           p[0]*v[0]+p[1]*v[1]+p[2]*v[2] ]);
}

// 2Dãƒãƒªã‚´ãƒ³AABB
function bounds2D(poly2D){
  let minx=+Infinity,miny=+Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const [x,y] of poly2D){
    if(x<minx) minx=x; if(x>maxx) maxx=x;
    if(y<miny) miny=y; if(y>maxy) maxy=y;
  }
  return {minx, miny, maxx, maxy};
}

// å‡¸å¤šè§’å½¢å†…åˆ¤å®šï¼ˆCCWæƒ³å®šï¼‰
function pointInConvexPoly(px,py, poly){
  const n=poly.length;
  let sign=0;
  for(let i=0;i<n;i++){
    const [ax,ay]=poly[i], [bx,by]=poly[(i+1)%n];
    const cross = (bx-ax)*(py-ay) - (by-ay)*(px-ax);
    if (cross!==0){
      const s = cross>0? 1:-1;
      if(sign===0) sign=s;
      else if(s!==sign) return false;
    }
  }
  return true;
}

// 2Dä¸‰è§’å½¢ï¼šå†…/å¤–ï¼‹ãƒãƒªã‚»ãƒ³
function pointInTri2D(px,py, ax,ay, bx,by, cx,cy, eps=-1e-6){
  const v0x=bx-ax, v0y=by-ay;
  const v1x=cx-ax, v1y=cy-ay;
  const v2x=px-ax, v2y=py-ay;
  const den = v0x*v1y - v0y*v1x;
  if (Math.abs(den) < 1e-12) return null;
  const v = (v2x*v1y - v2y*v1x)/den;
  const w = (v0x*v2y - v0y*v2x)/den;
  const u = 1 - v - w;
  if (u>=eps && v>=eps && w>=eps) return {u,v,w};
  return null;
}

// 2Då¤šè§’å½¢ã®ç¬¦å·ä»˜ãé¢ç©ï¼ˆCCWãªã‚‰æ­£ï¼‰
function signedArea2D(poly){
  let a=0;
  for(let i=0;i<poly.length;i++){
    const [x1,y1]=poly[i], [x2,y2]=poly[(i+1)%poly.length];
    a += x1*y2 - x2*y1;
  }
  return 0.5*a;
}

// é¢å¹³é¢ã¸å¼µã£ã¦æç”»ï¼ˆé ‚ç‚¹0èµ·ç‚¹ã®ä¸‰è§’ãƒ•ã‚¡ãƒ³ï¼‰ï¼ˆtargetEdgePx ãŒã‚ã‚Œã°è¾ºé•·ã‚’å„ªå…ˆï¼‰
function renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize, targetEdgePx=null){
  // 1) æ³•ç·šã¨åŸºåº•
  const n = faceNormalOfPolygon(poly3D);
  const {u,v} = basisUVfromNormal(n);

  // 2) 3Dâ†’2Dï¼ˆç”Ÿã®é¢å†…åº§æ¨™ï¼‰
  let poly2D = projectPolyToPlane2D(poly3D, u, v);

  // CCWä¿è¨¼
  if (signedArea2D(poly2D) < 0){
    poly2D.reverse();
    poly3D = [...poly3D].reverse();
  }

  // 3) ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ±ºã‚ã‚‹
  const rawBounds = bounds2D(poly2D);
  const rawW = rawBounds.maxx - rawBounds.minx;
  const rawH = rawBounds.maxy - rawBounds.miny;
  const fitScale = 0.9 * Math.min(faceSize/rawW, faceSize/rawH); // å¾“æ¥ã®ã€Œæ ã«ãƒ•ã‚£ãƒƒãƒˆã€

  let scale = fitScale;
  if (targetEdgePx != null){
    // â€œè¾ºé•·å„ªå…ˆâ€ã‚¹ã‚±ãƒ¼ãƒ«ï¼š rawã®å¹³å‡è¾ºé•·ã‚’ targetEdgePx ã«åˆã‚ã›ã‚‹
    const rawEdge = avgEdgeLen2D(poly2D);
    const edgeScale = targetEdgePx / rawEdge;
    // ãŸã ã—ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã¯ã¿å‡ºã™å ´åˆã¯ãƒ•ã‚£ãƒƒãƒˆä¸Šé™ã§æŠ‘ãˆã‚‹
    scale = Math.min(edgeScale, fitScale);
  }

  // 4) ã‚¹ã‚±ãƒ¼ãƒ«ï¼†ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°
  const cx = (rawBounds.minx + rawBounds.maxx)/2;
  const cy = (rawBounds.miny + rawBounds.maxy)/2;
  const P2 = poly2D.map(([x,y])=> [ (x-cx)*scale + faceSize/2, (y-cy)*scale + faceSize/2 ]);

  // 5) æç”»ï¼ˆå¾“æ¥åŒæ§˜ï¼‰
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  const xs = P2.map(p=>p[0]), ys = P2.map(p=>p[1]);
  const bbx0 = Math.max(0, Math.floor(Math.min(...xs)));
  const bbx1 = Math.min(faceSize-1, Math.ceil (Math.max(...xs)));
  const bby0 = Math.max(0, Math.floor(Math.min(...ys)));
  const bby1 = Math.min(faceSize-1, Math.ceil (Math.max(...ys)));

  for(let py=bby0; py<=bby1; py++){
    for(let px=bbx0; px<=bbx1; px++){
      if(!pointInConvexPoly(px+0.5, py+0.5, P2)) continue;

      let color = null;
      for(let i=1;i<P2.length-1;i++){
        const A=P2[0], B=P2[i], C=P2[i+1];
        const bc = pointInTri2D(px+0.5, py+0.5, A[0],A[1], B[0],B[1], C[0],C[1]);
        if(!bc) continue;

        const A3 = poly3D[0], B3 = poly3D[i], C3 = poly3D[i+1];
        let X = bc.u*A3[0] + bc.v*B3[0] + bc.w*C3[0];
        let Y = bc.u*A3[1] + bc.v*B3[1] + bc.w*C3[1];
        let Z = bc.u*A3[2] + bc.v*B3[2] + bc.w*C3[2];
        const inv = 1/Math.hypot(X,Y,Z);
        const dx = X*inv, dy = Y*inv, dz = Z*inv;

        const {lat,lon} = dirToLonLat(dx,dy,dz);
        const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
        const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
        color = bilinearInterpolateEquirect(eData, ex, ey, ew, eh);
        break;
      }
      if(color){
        const idx = (py*faceSize + px)*4;
        data[idx  ] = color[0];
        data[idx+1] = color[1];
        data[idx+2] = color[2];
        data[idx+3] = color[3];
      }
    }
  }
  ctx.putImageData(img,0,0);
  return {canvas, vertices2D: P2}; // 2Dé ‚ç‚¹åº§æ¨™ã‚‚è¿”ã™
}


/* ============================= æ­£å…­é¢ä½“ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ï¼‰ ============================= */
// ã‚­ãƒ¥ãƒ¼ãƒ–ã®å„é¢ã«ãŠã‘ã‚‹ (u,v)âˆˆ[-1,1]Ã—[-1,1] â†’ æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ« dir ã‚’è¿”ã™
// å³æ‰‹ç³»ã§ y=ä¸Š, x=å³, z=å‰(+Z) ã‚’æƒ³å®šï¼ˆequirectã¯ atan2(x,z) ã‚’ä½¿ç”¨ï¼‰
function cubeUVToDir(face, u, v){
  // vã¯ç”»åƒåº§æ¨™ã‹ã‚‰ä¸ŠãŒæ­£ã«ãªã‚‹ã‚ˆã†ã«å¤‰æ›æ¸ˆã¿ã‚’æ¸¡ã™å‰æ
  // æ…£ç”¨ã®ã²ã¨ã¤ã®å–ã‚Šå›ã—ï¼šPX/NX/PY/NY/PZ/NZ
  switch(face){
    case 'px': return normalize([ 1,  v, -u ]);
    case 'nx': return normalize([-1,  v,  u ]);
    case 'py': return normalize([ u,  1,  v ]);
    case 'ny': return normalize([ u, -1, -v ]);
    case 'pz': return normalize([ u,  v,  1 ]);
    case 'nz': return normalize([-u,  v, -1 ]);
  }
  function normalize([x,y,z]){
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv,y*inv,z*inv];
  }
}

function renderCubeFace(eData, ew, eh, faceName, faceSize){
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  for(let py=0; py<faceSize; py++){
    // ç”»åƒåº§æ¨™â†’vï¼ˆä¸Šï¼‹ï¼‰: v = 1 - 2*(y+0.5)/N
    const v = 1 - 2*((py + 0.5)/faceSize);
    for(let px=0; px<faceSize; px++){
      // ç”»åƒåº§æ¨™â†’uï¼ˆå³ï¼‹ï¼‰
      const u = 2*((px + 0.5)/faceSize) - 1;

      const [dx,dy,dz] = cubeUVToDir(faceName, u, v);
      const {lat, lon} = dirToLonLat(dx,dy,dz);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      const c = bilinearInterpolateEquirect(eData, ex, ey, ew, eh);

      const idx = (py*faceSize + px)*4;
      data[idx  ] = c[0];
      data[idx+1] = c[1];
      data[idx+2] = c[2];
      data[idx+3] = c[3];
    }
  }
  ctx.putImageData(img,0,0);
  return canvas;
}

function convertEquirectToCube(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const order = ['px','nx','py','ny','pz','nz'];
  const names = {
    px:'px(+X)', nx:'nx(-X)', py:'py(+Y)', ny:'ny(-Y)', pz:'pz(+Z)', nz:'nz(-Z)'
  };
  const faces = [];
  order.forEach(f=>{


// 20250906+ for Cubeå±•é–‹ã«ç‰¹å®šã«äºŒé¢ã®ã¿å·¦å³åè»¢ã—ã¦90åº¦cw, ucwã™ã‚‹
let canvas = renderCubeFace(eData, ew, eh, f, faceSize);

// â˜…ç´™ã®å±•é–‹å›³å‘ã‘ã®é¢å‘ãèª¿æ•´ï¼š
//  - ny(-Y) ã¯ã€Œå·¦å³åè»¢ â†’ æ™‚è¨ˆå›ã‚Š90Â°ã€
//  - py(+Y) ã¯ã€Œå·¦å³åè»¢ â†’ åæ™‚è¨ˆå›ã‚Š90Â°ã€
if (f === 'ny'){
  canvas = flipHThenRotate90(canvas, 'cw');
} else if (f === 'py'){
  canvas = flipHThenRotate90(canvas, 'ccw');
}

    
    faces.push({name: names[f], canvas});
  });
  return faces;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆåˆ‡é ‚äºŒåé¢ä½“ï¼‰ ============================= */
function convertEquirectToTruncatedIcosahedron(equirectImage, faceSize, t=1/3){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {pentagons, hexagons} = truncatedIcosahedronData(t);

  // ---- å…­è§’å½¢ã®åŸºæº–è¾ºé•·ï¼ˆpxï¼‰ã‚’æ±ºã‚ã‚‹ ----
  // ä»£è¡¨ã¨ã—ã¦ hexagons[0] ã‚’é¢å†…æŠ•å½±ã—ã¦ã€"ãƒ•ã‚£ãƒƒãƒˆæç”»"ã§ã®å¹³å‡è¾ºé•·ã‚’æ±‚ã‚ã‚‹
  (function ensureHexExists(){
    if(!hexagons.length) throw new Error('hexagons not found');
  })();

  // æŠ•å½±ã ã‘ã—ã¦ fitScale * rawEdge ã‚’è¨ˆç®—ï¼ˆæç”»ã¯ã—ãªã„ï¼‰
  function projectedAvgEdgeLenIfFitted(poly3D){
    const n = faceNormalOfPolygon(poly3D);
    const {u,v} = basisUVfromNormal(n);
    const raw2 = projectPolyToPlane2D(poly3D, u, v);
    if (signedArea2D(raw2) < 0) raw2.reverse();
    const {minx,miny,maxx,maxy} = bounds2D(raw2);
    const rawW = maxx-minx, rawH = maxy-miny;
    const fitScale = 0.9 * Math.min(faceSize/rawW, faceSize/rawH);
    return avgEdgeLen2D(raw2) * fitScale;
  }
  const hexEdgePx = projectedAvgEdgeLenIfFitted(hexagons[0]);

  // ---- æç”»ï¼šå…­è§’å½¢ï¼ˆåŸºæº–ã©ãŠã‚Šï¼ãƒ•ã‚£ãƒƒãƒˆï¼‰ï¼äº”è§’å½¢ï¼ˆè¾ºé•·åˆã‚ã›ï¼‰ ----
  const faces = [];

  // äº”è§’å½¢ï¼ˆè¾ºé•·ã‚’ hexEdgePx ã«åˆã‚ã›ã‚‹ï¼å¿…è¦ãªã‚‰ç¸®å°ï¼‰
  pentagons.forEach((poly, i)=>{
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly, faceSize, /*targetEdgePx*/ hexEdgePx).canvas;
    faces.push({name:`pent_${String(i).padStart(2,'0')}`, kind:'P', canvas, poly3:poly});
  });

  // å…­è§’å½¢ï¼ˆå¾“æ¥ã©ãŠã‚Šãƒ•ã‚£ãƒƒãƒˆã€‚â€»å¿…è¦ãªã‚‰åŒã˜ target ã‚’æ¸¡ã—ã¦ã‚‚OKï¼‰
  hexagons.forEach((poly, i)=>{
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly, faceSize, /*targetEdgePx*/ null).canvas;
    faces.push({name:`hex_${String(i).padStart(2,'0')}`, kind:'H', canvas, poly3:poly});
  });

  return faces;
}

// é ‚ç‚¹åº§æ¨™ã‚’ç›´æ¥å—ã‘å–ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³
function splitAndTransformTriangleWithVertices(srcCanvas, vertices, targetEdgeLen){
  if(!vertices || vertices.length !== 3) {
    return [srcCanvas, srcCanvas, srcCanvas];
  }
  
  // é‡å¿ƒ
  const cx = (vertices[0][0] + vertices[1][0] + vertices[2][0]) / 3;
  const cy = (vertices[0][1] + vertices[1][1] + vertices[2][1]) / 3;
  const center = [cx, cy];
  
  // 3ã¤ã®äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’å®šç¾©
  const triangles = [
    [vertices[0], center, vertices[1]],
    [vertices[1], center, vertices[2]],
    [vertices[2], center, vertices[0]]
  ];
  
  // å„ä¸‰è§’å½¢ã‚’ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã«å¤‰å½¢(ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¾ºé•·ã‚’æ¸¡ã™)
  const results = triangles.map(tri => transformTo90_45_45(srcCanvas, tri, targetEdgeLen));
  
  return results;
}

/* ============================= ä¸‰è§’å½¢åˆ†å‰²ãƒ»å¤‰å½¢å‡¦ç† ============================= */
// æ­£ä¸‰è§’å½¢ã‚’é‡å¿ƒã§3åˆ†å‰²ã—ã€å„äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã«å¤‰å½¢
function splitAndTransformTriangle(srcCanvas){
  const size = srcCanvas.width;
  const ctx = srcCanvas.getContext('2d');
  const imgData = ctx.getImageData(0, 0, size, size);
  
  // ä¸‰è§’å½¢ã®å®Ÿéš›ã®é ‚ç‚¹ã‚’æ¤œå‡ºï¼ˆéé€æ˜ãƒ”ã‚¯ã‚»ãƒ«ã®å¢ƒç•Œã‹ã‚‰ï¼‰
  const vertices = detectTriangleVertices(imgData, size);
  if(!vertices || vertices.length !== 3) {
    // æ¤œå‡ºå¤±æ•—æ™‚ã¯å…ƒã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ãã®ã¾ã¾è¿”ã™
    return [srcCanvas, srcCanvas, srcCanvas];
  }
  
  // é‡å¿ƒ
  const cx = (vertices[0][0] + vertices[1][0] + vertices[2][0]) / 3;
  const cy = (vertices[0][1] + vertices[1][1] + vertices[2][1]) / 3;
  const center = [cx, cy];
  
  // 3ã¤ã®äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’å®šç¾©
  const triangles = [
    [vertices[0], center, vertices[1]],
    [vertices[1], center, vertices[2]],
    [vertices[2], center, vertices[0]]
  ];
  
  // å„ä¸‰è§’å½¢ã‚’ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã«å¤‰å½¢
  const results = triangles.map(tri => transformTo90_45_45(srcCanvas, tri));
  
  return results;
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰ä¸‰è§’å½¢ã®é ‚ç‚¹ã‚’æ¤œå‡º
function detectTriangleVertices(imgData, size){
  const data = imgData.data;
  let minY = size, maxY = 0;
  let topX = 0, bottomLeft = [0, 0], bottomRight = [0, 0];
  
  // ä¸Šç«¯ã®é ‚ç‚¹ã‚’æ¤œå‡º
  for(let y = 0; y < size; y++){
    for(let x = 0; x < size; x++){
      const alpha = data[(y * size + x) * 4 + 3];
      if(alpha > 10){
        if(y < minY){
          minY = y;
          topX = x;
        }
        if(y > maxY) maxY = y;
      }
    }
  }
  
  // ä¸‹ç«¯ã®å·¦å³é ‚ç‚¹ã‚’æ¤œå‡º
  let leftMost = size, rightMost = 0;
  for(let x = 0; x < size; x++){
    for(let y = Math.floor(maxY * 0.9); y <= maxY; y++){
      const alpha = data[(y * size + x) * 4 + 3];
      if(alpha > 10){
        if(x < leftMost){
          leftMost = x;
          bottomLeft = [x, y];
        }
        if(x > rightMost){
          rightMost = x;
          bottomRight = [x, y];
        }
      }
    }
  }
  
  return [[topX, minY], bottomLeft, bottomRight];
}

// äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ï¼ˆ90Â°-45Â°-45Â°ï¼‰ã«å¤‰å½¢
function transformTo90_45_45(srcCanvas, srcTri, targetEdgeLen){
  const size = srcCanvas.width;
  const outCanvas = document.createElement('canvas');
  outCanvas.width = size;
  outCanvas.height = size;
  const outCtx = outCanvas.getContext('2d');
  const srcCtx = srcCanvas.getContext('2d');
  
  // ã‚½ãƒ¼ã‚¹ç”»åƒãƒ‡ãƒ¼ã‚¿
  const srcData = srcCtx.getImageData(0, 0, size, size);
  const outData = outCtx.createImageData(size, size);
  
  // ã‚½ãƒ¼ã‚¹ä¸‰è§’å½¢ã®è¾ºé•·ã‚’è¨ˆç®—
  const edge01 = Math.hypot(srcTri[1][0] - srcTri[0][0], srcTri[1][1] - srcTri[0][1]);
  const edge12 = Math.hypot(srcTri[2][0] - srcTri[1][0], srcTri[2][1] - srcTri[1][1]);
  const edge20 = Math.hypot(srcTri[0][0] - srcTri[2][0], srcTri[0][1] - srcTri[2][1]);
  
  // æœ€é•·è¾ºã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆã“ã‚ŒãŒç›´è§’ä¸‰è§’å½¢ã®æ–œè¾ºã«ãªã‚‹ï¼‰
  let apexIdx = 0; // ç›´è§’ã®é ‚ç‚¹ï¼ˆæœ€é•·è¾ºã®å¯¾é ‚ç‚¹ï¼‰
  
  if(edge01 >= edge12 && edge01 >= edge20) {
    apexIdx = 2; // è¾º0-1ãŒæœ€é•·ãªã‚‰ã€é ‚ç‚¹2ãŒç›´è§’
  } else if(edge12 >= edge01 && edge12 >= edge20) {
    apexIdx = 0; // è¾º1-2ãŒæœ€é•·ãªã‚‰ã€é ‚ç‚¹0ãŒç›´è§’
  } else {
    apexIdx = 1; // è¾º2-0ãŒæœ€é•·ãªã‚‰ã€é ‚ç‚¹1ãŒç›´è§’
  }
  
  // ã‚½ãƒ¼ã‚¹ä¸‰è§’å½¢ã®é ‚ç‚¹ã‚’å†é…ç½®ï¼ˆapex, left, rightï¼‰
  const srcApex = srcTri[apexIdx];
  const srcLeft = srcTri[(apexIdx + 1) % 3];
  const srcRight = srcTri[(apexIdx + 2) % 3];
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ï¼ˆ90Â°é ‚ç‚¹ã‚’ä¸Šã«é…ç½®ã€æ–œè¾º = targetEdgeLen ã«åˆã‚ã›ã‚‹ï¼‰
  const halfBase = targetEdgeLen / 2; // æ–œè¾ºã®åŠåˆ†
  
  const tgtApex = [size / 2, size / 2 - halfBase * 0.5]; // ä¸Šï¼ˆ90Â°é ‚ç‚¹ï¼‰
  const tgtLeft = [size / 2 - halfBase, size / 2 + halfBase * 0.5]; // å·¦ä¸‹
  const tgtRight = [size / 2 + halfBase, size / 2 + halfBase * 0.5]; // å³ä¸‹
  
  // ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ã«å¤‰æ›
  for(let py = 0; py < size; py++){
    for(let px = 0; px < size; px++){
      // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸‰è§’å½¢å†…ã‹ãƒã‚§ãƒƒã‚¯
      const bc = getBarycentricCoords(px + 0.5, py + 0.5, tgtApex, tgtLeft, tgtRight);
      if(!bc) continue;
      
      // ãƒãƒªã‚»ãƒ³åº§æ¨™ã‚’ä½¿ã£ã¦ã‚½ãƒ¼ã‚¹åº§æ¨™ã‚’è¨ˆç®—
      const srcX = bc.u * srcApex[0] + bc.v * srcLeft[0] + bc.w * srcRight[0];
      const srcY = bc.u * srcApex[1] + bc.v * srcLeft[1] + bc.w * srcRight[1];
      
      // ã‚½ãƒ¼ã‚¹ç”»åƒã‹ã‚‰åŒç·šå½¢è£œé–“ã§ãƒ”ã‚¯ã‚»ãƒ«å–å¾—
      const color = bilinearSample(srcData, srcX, srcY, size, size);
      if(color){
        const idx = (py * size + px) * 4;
        outData.data[idx] = color[0];
        outData.data[idx + 1] = color[1];
        outData.data[idx + 2] = color[2];
        outData.data[idx + 3] = color[3];
      }
    }
  }
  
  outCtx.putImageData(outData, 0, 0);
  return outCanvas;
}

// ãƒãƒªã‚»ãƒ³åº§æ¨™ã‚’è¨ˆç®—ï¼ˆä¸‰è§’å½¢å†…ãªã‚‰u,v,wã‚’è¿”ã™ã€å¤–ãªã‚‰ nullï¼‰
function getBarycentricCoords(px, py, v0, v1, v2){
  const v0x = v1[0] - v0[0], v0y = v1[1] - v0[1];
  const v1x = v2[0] - v0[0], v1y = v2[1] - v0[1];
  const v2x = px - v0[0], v2y = py - v0[1];
  
  const den = v0x * v1y - v1x * v0y;
  if(Math.abs(den) < 1e-10) return null;
  
  const v = (v2x * v1y - v1x * v2y) / den;
  const w = (v0x * v2y - v2x * v0y) / den;
  const u = 1 - v - w;
  
  if(u >= -0.001 && v >= -0.001 && w >= -0.001) return {u, v, w};
  return null;
}

// åŒç·šå½¢ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
function bilinearSample(imgData, x, y, w, h){
  x = Math.max(0, Math.min(w - 1, x));
  y = Math.max(0, Math.min(h - 1, y));
  
  const x0 = Math.floor(x), x1 = Math.min(w - 1, x0 + 1);
  const y0 = Math.floor(y), y1 = Math.min(h - 1, y0 + 1);
  const dx = x - x0, dy = y - y0;
  
  const idx = (xx, yy) => (yy * w + xx) * 4;
  const get = (xx, yy) => {
    const i = idx(xx, yy);
    return [imgData.data[i], imgData.data[i+1], imgData.data[i+2], imgData.data[i+3]];
  };
  
  const c00 = get(x0, y0), c10 = get(x1, y0);
  const c01 = get(x0, y1), c11 = get(x1, y1);
  
  const c0 = c00.map((v, i) => v * (1 - dx) + c10[i] * dx);
  const c1 = c01.map((v, i) => v * (1 - dx) + c11[i] * dx);
  const c = c0.map((v, i) => v * (1 - dy) + c1[i] * dy);
  
  return c;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆæ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼‰ ============================= */
function convertEquirectToRhombicuboctahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {V, triangles, squares} = rhombicuboctahedronData();
  const faces = [];

  // æ­£æ–¹å½¢é¢ã®åŸºæº–è¾ºé•·ã‚’è¨ˆç®—
  const firstSquare = squares[0].map(idx => V[idx]);
  const refEdgeLen = projectedAvgEdgeLenIfFitted(firstSquare);

  // ä¸‰è§’å½¢é¢ï¼ˆ8å€‹ï¼‰- æ­£æ–¹å½¢ã¨è¾ºé•·ã‚’åˆã‚ã›ã‚‹ â†’ ã•ã‚‰ã«3åˆ†å‰²ã—ã¦ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã«å¤‰å½¢
  triangles.forEach((tri, i)=>{
    const poly3D = tri.map(idx => V[idx]);
    const result = renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize, refEdgeLen);
    const canvas = result.canvas;
    const vertices = result.vertices2D; // å®Ÿéš›ã®2Dé ‚ç‚¹åº§æ¨™ã‚’å–å¾—
    
    // æ­£ä¸‰è§’å½¢ã‚’3ã¤ã®ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã«åˆ†å‰²ãƒ»å¤‰å½¢ï¼ˆé ‚ç‚¹åº§æ¨™ã‚’æ¸¡ã™ï¼‰æ­£æ–¹å½¢ã®è¾ºé•·ã«åˆã‚ã›ã¦å¤‰å½¢
    const splitCanvases = splitAndTransformTriangleWithVertices(canvas, vertices, refEdgeLen);
    splitCanvases.forEach((splitCanvas, j)=>{
      const subName = String.fromCharCode(97 + j); // 'a', 'b', 'c'
      faces.push({name:`tri_${String(i).padStart(2,'0')}_${subName}`, canvas: splitCanvas});
    });
  });

  // æ­£æ–¹å½¢é¢ï¼ˆ18å€‹ï¼‰
  squares.forEach((quad, i)=>{
    const poly3D = quad.map(idx => V[idx]);
    const result = renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize);
    faces.push({name:`sq_${String(i).padStart(2,'0')}`, canvas: result.canvas});
  });

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆåˆ‡é ‚äºŒåé¢ä½“ã‹ã‚‰æµç”¨ï¼‰
  function projectedAvgEdgeLenIfFitted(poly3D){
    const n = faceNormalOfPolygon(poly3D);
    const {u,v} = basisUVfromNormal(n);
    const raw2 = projectPolyToPlane2D(poly3D, u, v);
    if (signedArea2D(raw2) < 0) raw2.reverse();
    const {minx,miny,maxx,maxy} = bounds2D(raw2);
    const rawW = maxx-minx, rawH = maxy-miny;
    const fitScale = 0.9 * Math.min(faceSize/rawW, faceSize/rawH);
    return avgEdgeLen2D(raw2) * fitScale;
  }

  return faces;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆæ­£å››é¢ä½“ï¼‰ ============================= */
function convertEquirectToTetrahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {V, F} = tetrahedronData();
  const faces = [];

  // 4ã¤ã®ä¸‰è§’å½¢é¢
  F.forEach((tri, i)=>{
    const poly3D = tri.map(idx => V[idx]);
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize).canvas;
    faces.push({name:`tri_${String(i).padStart(2,'0')}`, canvas});
  });

  return faces;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆæ­£åäºŒé¢ä½“ï¼‰ ============================= */
function convertEquirectToDodecahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {V, F} = dodecahedronData();
  const faces = [];

  // 12å€‹ã®äº”è§’å½¢é¢
  F.forEach((pent, i)=>{
    const poly3D = pent.map(idx => V[idx]);
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize).canvas;
    faces.push({name:`pent_${String(i).padStart(2,'0')}`, canvas});
  });

  return faces;
}

/* ============================= UI ãƒ­ã‚¸ãƒƒã‚¯ ============================= */
const el = {
  uploadArea: document.getElementById('uploadArea'),
  fileInput: document.getElementById('fileInput'),
  inputInfo: document.getElementById('inputInfo'),
  polyType: document.getElementById('polyType'),
  faceSize: document.getElementById('faceSize'),
  truncRow: document.getElementById('truncRow'),
  truncRange: document.getElementById('truncRange'),
  truncNumber: document.getElementById('truncNumber'),
  runBtn: document.getElementById('runBtn'),
  clearBtn: document.getElementById('clearBtn'),
  fmt: document.getElementById('fmt'),
  qualityRange: document.getElementById('qualityRange'),
  qualityLabel: document.getElementById('qualityLabel'),
  prefix: document.getElementById('prefix'),
  faces: document.getElementById('faces'),
  dlAllBtn: document.getElementById('dlAllBtn'),
  gridBtn: document.getElementById('gridBtn'),
  gridCanvas: document.getElementById('gridCanvas'),
  gridWrap: document.getElementById('gridWrap'),
  gridDownload: document.getElementById('gridDownload'),
  gridInfo: document.getElementById('gridInfo'),
  
    drawGuideBtn: document.getElementById('drawGuideBtn'),
    guideColor: document.getElementById('guideColor'),
    guideWidth: document.getElementById('guideWidth'),
  
  layoutBtn: document.getElementById('layoutBtn'),
  layoutDownload: document.getElementById('layoutDownload'),
  layoutInfo: document.getElementById('layoutInfo'),
  layoutCanvas: document.getElementById('layoutCanvas'),
  layoutWrap: document.getElementById('layoutWrap'),
};

let inputImage = null;
let originalImage = null; // å¸¸ã«ç”Ÿã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ä¿æŒ

let lastFaces = []; // {name, canvas}[]
let lastPoly = '';  // 'cube' | 'icosa' | 'truncated'

function loadImage(file){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
}

function setInputInfo(img){
  if(!img) { el.inputInfo.textContent = 'æœªèª­ã¿è¾¼ã¿'; return; }
  el.inputInfo.textContent = `å…¥åŠ›ï¼š${img.width} Ã— ${img.height} pxï¼ˆã‚¨ã‚¯ã‚¤æƒ³å®šï¼‰`;
}

function renderFacesToPanel(faces){
  el.faces.innerHTML = '';
  faces.forEach(({name, canvas})=>{
    const box = document.createElement('div');
    box.className = 'face';
    const p = document.createElement('p'); p.textContent = name;
    const save = document.createElement('button');
    save.className = 'btn ghost'; save.textContent = 'ä¿å­˜';
    save.onclick = ()=>{
      const mime = el.fmt.value;
      const quality = parseFloat(el.qualityRange.value);
      const url = (mime==='image/png') ? canvas.toDataURL(mime)
                                       : canvas.toDataURL(mime, quality);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${el.prefix.value}${name}.${extFromMime(mime)}`;
      a.click();
    };
    box.appendChild(p);
    box.appendChild(canvas);
    box.appendChild(save);
    el.faces.appendChild(box);
  });
}

function extFromMime(mime){
  if(mime==='image/png') return 'png';
  if(mime==='image/jpeg') return 'jpg';
  if(mime==='image/webp') return 'webp';
  return 'png';
}

// è¿½åŠ ï¼šCanvasâ†’Blob å¤‰æ›ï¼ˆawaitå¯¾å¿œï¼‰
async function canvasToBlob(canvas, mime, quality){
  return await new Promise(resolve => canvas.toBlob(resolve, mime, quality));
}

// è¿½åŠ ï¼šZIPåŒ–ã—ã¦1å›ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ä¿å­˜
async function zipAndDownload(fileEntries, zipBaseName){
  const zip = new JSZip();
  for (const { path, blob } of fileEntries){
    zip.file(path, blob);
  }
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${zipBaseName}.zip`;
  a.click();
  // ä¸€å®šæ™‚é–“å¾Œã«URLè§£æ”¾
  setTimeout(()=> URL.revokeObjectURL(url), 10000);
}

function buildGridAndPreview(faces){
  if(!faces.length) return;
  const N = faces.length;
  const cols = Math.ceil(Math.sqrt(N));
  const rows = Math.ceil(N / cols);

  const w = faces[0].canvas.width;
  const h = faces[0].canvas.height;

  const g = el.gridCanvas;
  g.width = cols * w;
  g.height = rows * h;

  const ctx = g.getContext('2d');
  ctx.clearRect(0,0,g.width,g.height);

  faces.forEach(({canvas}, i)=>{
    const r = Math.floor(i / cols);
    const c = i % cols;
    ctx.drawImage(canvas, c*w, r*h);
  });

  el.gridWrap.style.display = 'block';
  el.gridInfo.textContent = `ã‚¿ã‚¤ãƒ«ï¼š${g.width} Ã— ${g.height} pxï¼ˆ${cols}Ã—${rows}é¢ï¼‰`;

    el.gridDownload.style.display = 'inline-block';
    el.gridDownload.textContent = 'ã‚¿ã‚¤ãƒ«ã‚’ä¿å­˜';
    el.gridDownload.removeAttribute('onclick');
    
    el.gridDownload.onclick = async () => {
        const mime = el.fmt.value;
        const quality = parseFloat(el.qualityRange.value);
        const ext = extFromMime(mime);
        const prefix = el.prefix.value || '';
        const blob = await canvasToBlob(g, mime, quality);
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${prefix}${lastPoly}_grid.${ext}`;
        a.click();
        
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    };
}

// å˜ä½ãƒ™ã‚¯ãƒˆãƒ«é–“ã®SLERPï¼ˆç·šå½¢â†’æ­£è¦åŒ–ã®è¿‘ä¼¼ã§ã‚‚OKã ãŒã€ã“ã“ã¯æ»‘ã‚‰ã‹ã•é‡è¦–ï¼‰
function slerpUnit(A,B,t){
  // å†…ç©ã§è§’åº¦
  const dot = Math.max(-1, Math.min(1, A[0]*B[0] + A[1]*B[1] + A[2]*B[2]));
  const omega = Math.acos(dot);
  if (omega < 1e-6){
    return [A[0],A[1],A[2]];
  }
  const s1 = Math.sin((1-t)*omega)/Math.sin(omega);
  const s2 = Math.sin(t*omega)/Math.sin(omega);
  const x = s1*A[0] + s2*B[0];
  const y = s1*A[1] + s2*B[1];
  const z = s1*A[2] + s2*B[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

// è¾ºãƒªã‚¹ãƒˆï¼ˆå„è¾ºã¯ [A,B]ï¼šå˜ä½ãƒ™ã‚¯ãƒˆãƒ«ï¼‰ã‚’å¤šé¢ä½“ã‚¿ã‚¤ãƒ—ã‹ã‚‰åé›†
function gatherEdges(polyType, t=1/3){
  const edges = [];
  const addEdge = (a,b)=>{
    // æ–¹å‘ã«ä¾ã‚‰ãªã„ä¸€æ„åŒ–
    const key = a.map(v=>v.toFixed(6)).join(',') + '|' + b.map(v=>v.toFixed(6)).join(',');
    const keyR = b.map(v=>v.toFixed(6)).join(',') + '|' + a.map(v=>v.toFixed(6)).join(',');
    if (!addEdge._set) addEdge._set = new Set();
    if (addEdge._set.has(key) || addEdge._set.has(keyR)) return;
    addEdge._set.add(key); edges.push([a,b]);
  };

  if (polyType === 'tetrahedron'){
    const {V,F} = tetrahedronData();
    const ek = (i,j)=> i<j ? `${i}_${j}` : `${j}_${i}`;
    const seen = new Set();
    F.forEach(f=>{
      for(let k=0;k<3;k++){
        const a=f[k], b=f[(k+1)%3];
        const key = ek(a,b);
        if (seen.has(key)) continue;
        seen.add(key);
        addEdge(V[a], V[b]);
      }
    });
  } else if (polyType === 'dodecahedron'){
    const {V,F} = dodecahedronData();
    const ek = (i,j)=> i<j ? `${i}_${j}` : `${j}_${i}`;
    const seen = new Set();
    F.forEach(f=>{
      for(let k=0;k<5;k++){
        const a=f[k], b=f[(k+1)%5];
        const key = ek(a,b);
        if (seen.has(key)) continue;
        seen.add(key);
        addEdge(V[a], V[b]);
      }
    });
  } else if (polyType === 'icosa'){
    const {V,F} = icosahedronData();
    const ek = (i,j)=> i<j ? `${i}_${j}` : `${j}_${i}`;
    const seen = new Set();
    F.forEach(f=>{
      for(let k=0;k<3;k++){
        const a=f[k], b=f[(k+1)%3];
        const key = ek(a,b);
        if (seen.has(key)) continue;
        seen.add(key);
        addEdge(V[a], V[b]);
      }
    });
  } else if (polyType === 'octa'){
    const {V,F} = octahedronData();
    const ek = (i,j)=> i<j ? `${i}_${j}` : `${j}_${i}`;
    const seen = new Set();
    F.forEach(f=>{
      for(let k=0;k<3;k++){
        const a=f[k], b=f[(k+1)%3];
        const key = ek(a,b);
        if (seen.has(key)) continue;
        seen.add(key);
        addEdge(V[a], V[b]);
      }
    });
  } else if (polyType === 'cube'){
    // ç«‹æ–¹ä½“ã®8é ‚ç‚¹ï¼ˆæ­£è¦åŒ–ä¸è¦ï¼šÂ±1ï¼‰
    const V = [];
    [-1,1].forEach(x=>[-1,1].forEach(y=>[-1,1].forEach(z=>{
      const inv = 1/Math.hypot(x,y,z);
      V.push([x*inv,y*inv,z*inv]);
    })));
    // ã‚¨ãƒƒã‚¸ï¼ˆåº§æ¨™ãŒ1è»¸ã ã‘ç•°ãªã‚‹çµ„ã¿åˆã‚ã›ï¼‰
    const idx = (sx,sy,sz)=> (sx+1)/2*4 + (sy+1)/2*2 + (sz+1)/2;
    const signs=[-1,1];
    signs.forEach(x=>{
      signs.forEach(y=>{
        addEdge(V[idx(x,y,-1)], V[idx(x,y, 1)]);
      });
    });
    signs.forEach(x=>{
      signs.forEach(z=>{
        addEdge(V[idx(x,-1,z)], V[idx(x, 1,z)]);
      });
    });
    signs.forEach(y=>{
      signs.forEach(z=>{
        addEdge(V[idx(-1,y,z)], V[idx( 1,y,z)]);
      });
    });
  } else if (polyType === 'rhombicubocta') {
    // æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼šä¸‰è§’å½¢/æ­£æ–¹å½¢ãƒãƒªã‚´ãƒ³ã‹ã‚‰é€£ç¶šè¾º
    const {triangles, squares} = rhombicuboctahedronData();
    const polyEdges = (poly)=> poly.forEach((p,i)=>{
      const q = poly[(i+1)%poly.length];
      addEdge(V[p], V[q]);
    });
    const {V} = rhombicuboctahedronData();
    triangles.forEach(tri => tri.forEach((p,i)=>{
      const q = tri[(i+1)%3];
      addEdge(V[p], V[q]);
    }));
    squares.forEach(sq => sq.forEach((p,i)=>{
      const q = sq[(i+1)%4];
      addEdge(V[p], V[q]);
    }));
  } else {
    // åˆ‡é ‚äºŒåé¢ä½“ï¼šäº”è§’å½¢/å…­è§’å½¢ãƒãƒªã‚´ãƒ³ã‹ã‚‰é€£ç¶šè¾º
    const {pentagons, hexagons} = truncatedIcosahedronData(t);
    const polyEdges = (poly)=> poly.forEach((p,i)=>{
      const q = poly[(i+1)%poly.length];
      addEdge(p,q);
    });
    pentagons.forEach(polyEdges);
    hexagons.forEach(polyEdges);
  }
  return edges;
}

// è¾ºã‚’ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼(å…ƒç”»åƒ)ã¸æç”»ã—ã¦ä¿å­˜
async function drawGuideOnEquirectAndSave(img, polyType, opts){
  const {color='#ff2d55', width=2, t=1/3, samples=256, mime='image/png', quality=0.92, prefix='poly_'} = opts||{};
  const ew = img.width, eh = img.height;

  const cv = document.createElement('canvas');
  cv.width = ew; cv.height = eh;
  const ctx = cv.getContext('2d');
  ctx.drawImage(img, 0, 0);

  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  const edges = gatherEdges(polyType, t);

  edges.forEach(([A,B])=>{
    // ã‚µãƒ³ãƒ—ãƒ«åˆ—
    const pts = [];
    for(let i=0;i<=samples;i++){
      const tt = i/samples;
      const [x,y,z] = slerpUnit(A,B,tt);
      const {lat,lon} = dirToLonLat(x,y,z);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      pts.push([ex,ey]);
    }
    // çµŒåº¦ã¾ãŸãï¼ˆÂ±Ï€ï¼‰ã®æŠ˜ã‚Œã‚’åˆ†å‰²ã—ã¦æã
    let seg = [pts[0]];
    for(let i=1;i<pts.length;i++){
      const [x0,_y0]=seg[seg.length-1];
      const [x1,_y1]=pts[i];
      if (Math.abs(x1 - x0) > ew*0.5){
        // ã‚¹ãƒ—ãƒªãƒƒãƒˆ
        ctx.beginPath();
        ctx.moveTo(seg[0][0], seg[0][1]);
        for(let k=1;k<seg.length;k++) ctx.lineTo(seg[k][0], seg[k][1]);
        ctx.stroke();
        seg = [pts[i]];
      }else{
        seg.push(pts[i]);
      }
    }
    if (seg.length>1){
      ctx.beginPath();
      ctx.moveTo(seg[0][0], seg[0][1]);
      for(let k=1;k<seg.length;k++) ctx.lineTo(seg[k][0], seg[k][1]);
      ctx.stroke();
    }
  });

  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  const blob = await new Promise(res=> cv.toBlob(res, mime, quality));
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const polyTag = (polyType==='cube'?'cube': polyType==='octa'?'octa': polyType==='icosa'?'icosa':'truncated');
  a.download = `${prefix}${polyTag}_guide.${extFromMime(mime)}`;
  a.href = url; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 10000);
}




/* --------- ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰ --------- */



// ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆç¾¤ã®è¿‘ãã«è¿½è¨˜ï¼‰
document.getElementById('drawGuideBtn').addEventListener('click', async ()=>{
  if(!inputImage){ alert('å…ˆã«ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚'); return; }
  const type = el.polyType.value; // 'cube' | 'icosa' | 'truncated'
  const t = Math.max(0.15, Math.min(0.5, parseFloat(el.truncNumber?.value||'0.333'))); // åˆ‡é ‚ç”¨
  const mime = el.fmt.value;
  const quality = parseFloat(el.qualityRange.value);
  const prefix = el.prefix.value || '';
  const color = document.getElementById('guideColor').value;
  const width = Math.max(1, Math.min(8, parseInt(document.getElementById('guideWidth').value||'2',10)));
  await drawGuideOnEquirectAndSave(inputImage, type, {color, width, t, mime, quality, prefix});
});




el.uploadArea.addEventListener('dragover', e=>{
  e.preventDefault(); el.uploadArea.classList.add('dragover');
});
el.uploadArea.addEventListener('dragleave', e=>{
  el.uploadArea.classList.remove('dragover');
});
el.uploadArea.addEventListener('drop', async e=>{
  e.preventDefault(); el.uploadArea.classList.remove('dragover');
  const file = e.dataTransfer.files?.[0];
  if(!file) return;
  
 originalImage = await loadImage(file);// 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
 inputImage = originalImage;         // æ—¢å®šã¯å¸¸ã«ã‚ªãƒªã‚¸ãƒŠãƒ«
 setInputInfo(originalImage);
  
});
el.fileInput.addEventListener('change', async e=>{
  const file = e.target.files?.[0];
  if(!file) return;
 // 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
    // ã“ã“ã§ originalImage ã‚‚å¿…ãšæ›´æ–°ã—ã€inputImage ã‚’æƒãˆã‚‹
    originalImage = await loadImage(file);
    inputImage = originalImage;
setInputInfo(originalImage);
});

el.polyType.addEventListener('change', ()=>{
  const trunc = el.polyType.value === 'truncated';
  el.truncRow.style.display = trunc ? 'block' : 'none';
});

el.truncRange.addEventListener('input', ()=>{
  el.truncNumber.value = el.truncRange.value;
});
el.truncNumber.addEventListener('input', ()=>{
  el.truncRange.value = el.truncNumber.value;
});

el.qualityRange.addEventListener('input', ()=>{
  el.qualityLabel.textContent = Number(el.qualityRange.value).toFixed(2);
});

el.runBtn.addEventListener('click', ()=>{
if(!originalImage){ alert('å…ˆã«ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚'); return; }
  const faceSize = Math.max(32, Math.min(4096, parseInt(el.faceSize.value || '512',10)));
  const type = el.polyType.value;


// â˜…è¦ä»¶é€šã‚Šã®ç½®æ›ãƒ­ã‚¸ãƒƒã‚¯ï¼š 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
//   octa/icosa/dodecahedron/truncated : å®Ÿè¡Œæ™‚ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’å·¦å³åè»¢ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã§ inputImage ã‚’ç½®æ›ã—ã¦ã‹ã‚‰ç¶šè¡Œ
//   ãã‚Œä»¥å¤–       : ç½®ãæ›ãˆãšï¼ˆå¸¸ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ä½¿ç”¨ï¼‰
if (type === 'octa' || type === 'icosa' || type === 'dodecahedron' || type === 'truncated'){
  inputImage = createHorizontallyFlippedCanvas(originalImage);
} else {
  inputImage = originalImage; // ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã¾ã¾
}




  let faces = [];
  if(type === 'cube'){
    faces = convertEquirectToCube(inputImage, faceSize);
  }else if(type === 'tetrahedron'){
    faces = convertEquirectToTetrahedron(inputImage, faceSize);
  }else if(type === 'octa'){
    faces = convertEquirectToOctahedron(inputImage, faceSize);
  }else if(type === 'icosa'){
    faces = convertEquirectToIcosahedron(inputImage, faceSize);
  }else if(type === 'dodecahedron'){
    faces = convertEquirectToDodecahedron(inputImage, faceSize);
  }else if(type === 'rhombicubocta'){
    faces = convertEquirectToRhombicuboctahedron(inputImage, faceSize);
  }else{
    const t = Math.max(0.15, Math.min(0.5, parseFloat(el.truncNumber.value||'0.333')));
    faces = convertEquirectToTruncatedIcosahedron(inputImage, faceSize, t);
  }
  
  lastFaces = faces;
  lastPoly = type;
  renderFacesToPanel(faces);
  el.gridWrap.style.display = 'none';
  el.gridDownload.style.display = 'none';
  el.gridInfo.textContent = '';
});

el.clearBtn.addEventListener('click', ()=>{
  lastFaces = [];
  el.faces.innerHTML = '';
  el.gridWrap.style.display = 'none';
  el.gridDownload.style.display = 'none';
  el.gridInfo.textContent = '';
});


// ZIPã§ã¾ã¨ã‚ã¦ä¿å­˜ã™ã‚‹ä»•æ§˜
el.dlAllBtn.addEventListener('click', async ()=>{
  if(!lastFaces.length){ alert('å…ˆã«å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚'); return; }

  const mime = el.fmt.value;
  const quality = parseFloat(el.qualityRange.value);
  const ext = extFromMime(mime);
  const prefix = el.prefix.value || '';

  // å€‹åˆ¥é¢ã‚’ZIPã¸è©°ã‚ã‚‹
  const files = [];
  for (const { name, canvas } of lastFaces){
    const blob = await canvasToBlob(canvas, mime, quality);
    files.push({ path: `${prefix}${name}.${ext}`, blob });
  }

  // ã‚‚ã—ã‚¿ã‚¤ãƒ«ãŒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¸ˆã¿ãªã‚‰ã€ã‚¿ã‚¤ãƒ«ã‚‚åŒæ¢±
  if (el.gridWrap.style.display === 'block'){
    const gBlob = await canvasToBlob(el.gridCanvas, mime, quality);
    files.push({ path: `${prefix}${lastPoly}_grid.${ext}`, blob: gBlob });
  }

  await zipAndDownload(files, `${prefix}${lastPoly}_all`);
});





el.gridBtn.addEventListener('click', ()=>{
  if(!lastFaces.length){ alert('å…ˆã«å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚'); return; }
  buildGridAndPreview(lastFaces);
});

/* ============================= å±•é–‹å›³ç”Ÿæˆ ============================= */

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰å®Ÿéš›ã®æç”»é ˜åŸŸï¼ˆéé€æ˜éƒ¨åˆ†ï¼‰ã®å¢ƒç•Œã‚’æ¤œå‡º
function detectDrawingBounds(canvas){
  const ctx = canvas.getContext('2d');
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imgData.data;
  
  let minX = canvas.width;
  let minY = canvas.height;
  let maxX = 0;
  let maxY = 0;
  
  // éé€æ˜ãƒ”ã‚¯ã‚»ãƒ«ã‚’æ¢ã—ã¦å¢ƒç•Œã‚’æ¤œå‡º
  for(let y = 0; y < canvas.height; y++){
    for(let x = 0; x < canvas.width; x++){
      const idx = (y * canvas.width + x) * 4;
      const alpha = data[idx + 3];
      
      if(alpha > 10){ // ã»ã¼é€æ˜ã§ãªã„å ´åˆ
        if(x < minX) minX = x;
        if(x > maxX) maxX = x;
        if(y < minY) minY = y;
        if(y > maxY) maxY = y;
      }
    }
  }
  
  // æç”»ãŒãªã„å ´åˆã¯å…¨ä½“ã‚’è¿”ã™
  if(minX > maxX || minY > maxY){
    return { x: 0, y: 0, width: canvas.width, height: canvas.height };
  }
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX + 1,
    height: maxY - minY + 1
  };
}

// æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®å±•é–‹å›³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šç¾©(ä¸ŠåŠçƒ)
function getRhombicuboctaLayout1(){
  const layout = {
    squares: [],
    triangles: []
  };
  
  // æ­£æ–¹å½¢ã‚’7x7ã®æ ¼å­çŠ¶ã«é…ç½®ï¼ˆsq_00 ~ sq_17ï¼‰
  // é †ç•ªã¯å¾Œã‹ã‚‰è‡ªç”±ã«å¤‰æ›´å¯èƒ½
  layout.squares = [
    // 0è¡Œç›®
    { name: 'sq_03', x: 3, y: 0, rotation: 270 },
    // 1è¡Œç›®
    { name: 'sq_07', x: 2, y: 1, rotation: 270 },
    { name: 'sq_09', x: 3, y: 1, rotation: 270 },
    { name: 'sq_06', x: 4, y: 1, rotation: 270 },
    // 2è¡Œç›®
    { name: 'sq_07', x: 1, y: 2, rotation: 180 },
    { name: 'sq_02', x: 3, y: 2, rotation: 270 },
    { name: 'sq_06', x: 5, y: 2, rotation: 0 },
    // 3è¡Œç›®
    { name: 'sq_11', x: 0, y: 3, rotation: 90 },
    { name: 'sq_15', x: 1, y: 3, rotation: 270 },
    { name: 'sq_17', x: 2, y: 3, rotation: 270 },
    { name: 'sq_12', x: 3, y: 3, rotation: 270 },
    { name: 'sq_16', x: 4, y: 3, rotation: 270 },
    { name: 'sq_14', x: 5, y: 3, rotation: 90 },
    { name: 'sq_10', x: 6, y: 3, rotation: 90 },
    // 4è¡Œç›®
    { name: 'sq_05', x: 1, y: 4, rotation: 0 },
    { name: 'sq_00', x: 3, y: 4, rotation: 270 },
    { name: 'sq_04', x: 5, y: 4, rotation: 180 },
    // 5è¡Œç›®
    { name: 'sq_05', x: 2, y: 5, rotation: 270 },
    { name: 'sq_08', x: 3, y: 5, rotation: 270 },
    { name: 'sq_04', x: 4, y: 5, rotation: 270 },
    // 6è¡Œç›®
    { name: 'sq_01', x: 3, y: 6, rotation: 270 },
  ];
  
  // ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’é…ç½®ï¼ˆtri_00_a ~ tri_07_c ã®24å€‹ï¼‰
  // position: 'top', 'right', 'bottom', 'left' ã§æ­£æ–¹å½¢1å€‹åˆ†ã®é ˜åŸŸå†…ã®ä½ç½®ã‚’æŒ‡å®š
  layout.triangles = [
    // x:2, y:0 ã®é ˜åŸŸ
    { name: 'tri_07_c', x: 2, y: 0, position: 'right', rotation: 0 },
    { name: 'tri_07_a', x: 2, y: 0, position: 'bottom', rotation: 0 },
    { name: 'tri_07_b', x: 2, y: 0, position: 'left', rotation: 0 },
    // x:0, y:2 ã®é ˜åŸŸ
    { name: 'tri_07_c', x: 0, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_07_a', x: 0, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_07_b', x: 0, y: 2, position: 'bottom', rotation: 0 },
    // x:4, y:0 ã®é ˜åŸŸ
    { name: 'tri_05_b', x: 4, y: 0, position: 'right', rotation: 0 },
    { name: 'tri_05_c', x: 4, y: 0, position: 'bottom', rotation: 0 },
    { name: 'tri_05_a', x: 4, y: 0, position: 'left', rotation: 0 },
    // x:6, y:2 ã®é ˜åŸŸ
    { name: 'tri_05_b', x: 6, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_05_c', x: 6, y: 2, position: 'left', rotation: 0 },
    { name: 'tri_05_a', x: 6, y: 2, position: 'top', rotation: 0 },
    // å·¦ä¸Šï¼ˆx:2, y:2 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_06_c', x: 2, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_06_a', x: 2, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_06_b', x: 2, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_06_c', x: 2, y: 2, position: 'left', rotation: 0 },
    // å³ä¸Šï¼ˆx:4, y:2 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_04_a', x: 4, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_04_a', x: 4, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_04_b', x: 4, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_04_c', x: 4, y: 2, position: 'left', rotation: 0 },
    // å·¦ä¸‹ï¼ˆx:2, y:4 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_02_b', x: 2, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_02_c', x: 2, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_02_a', x: 2, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_02_a', x: 2, y: 4, position: 'left', rotation: 0 },
    // å³ä¸‹ï¼ˆx:4, y:4 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_00_b', x: 4, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_00_c', x: 4, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_00_c', x: 4, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_00_a', x: 4, y: 4, position: 'left', rotation: 0 },
    // x:2, y:6 ã®é ˜åŸŸ
    { name: 'tri_03_b', x: 2, y: 6, position: 'left', rotation: 0 },
    { name: 'tri_03_c', x: 2, y: 6, position: 'top', rotation: 0 },
    { name: 'tri_03_a', x: 2, y: 6, position: 'right', rotation: 0 },
    // x:0, y:4 ã®é ˜åŸŸ
    { name: 'tri_03_b', x: 0, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_03_c', x: 0, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_03_a', x: 0, y: 4, position: 'bottom', rotation: 0 },
    // x:4, y:6 ã®é ˜åŸŸ
    { name: 'tri_01_c', x: 4, y: 6, position: 'left', rotation: 0 },
    { name: 'tri_01_a', x: 4, y: 6, position: 'top', rotation: 0 },
    { name: 'tri_01_b', x: 4, y: 6, position: 'right', rotation: 0 },
    // x:6, y:4 ã®é ˜åŸŸ
    { name: 'tri_01_c', x: 6, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_01_a', x: 6, y: 4, position: 'left', rotation: 0 },
    { name: 'tri_01_b', x: 6, y: 4, position: 'top', rotation: 0 },
  ];
  
  return layout;
}

// æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®å±•é–‹å›³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šç¾©(ä¸‹åŠçƒ)
function getRhombicuboctaLayout2(){
  const layout = {
    squares: [],
    triangles: []
  };
  
  // æ­£æ–¹å½¢ã‚’7x7ã®æ ¼å­çŠ¶ã«é…ç½®ï¼ˆsq_00 ~ sq_17ï¼‰
  // é †ç•ªã¯å¾Œã‹ã‚‰è‡ªç”±ã«å¤‰æ›´å¯èƒ½
  layout.squares = [
    // 0è¡Œç›®
    { name: 'sq_00', x: 3, y: 0, rotation: 270 },
    // 1è¡Œç›®
    { name: 'sq_05', x: 2, y: 1, rotation: 270 },
    { name: 'sq_08', x: 3, y: 1, rotation: 270 },
    { name: 'sq_04', x: 4, y: 1, rotation: 270 },
    // 2è¡Œç›®
    { name: 'sq_05', x: 1, y: 2, rotation: 180 },
    { name: 'sq_01', x: 3, y: 2, rotation: 270 },
    { name: 'sq_04', x: 5, y: 2, rotation: 0 },
    // 3è¡Œç›®
    { name: 'sq_17', x: 0, y: 3, rotation: 90 },
    { name: 'sq_15', x: 1, y: 3, rotation: 90 },
    { name: 'sq_11', x: 2, y: 3, rotation: 270 },
    { name: 'sq_13', x: 3, y: 3, rotation: 270 },
    { name: 'sq_10', x: 4, y: 3, rotation: 270 },
    { name: 'sq_14', x: 5, y: 3, rotation: 270 },
    { name: 'sq_16', x: 6, y: 3, rotation: 90 },
    // 4è¡Œç›®
    { name: 'sq_07', x: 1, y: 4, rotation: 0 },
    { name: 'sq_03', x: 3, y: 4, rotation: 270 },
    { name: 'sq_06', x: 5, y: 4, rotation: 180 },
    // 5è¡Œç›®
    { name: 'sq_07', x: 2, y: 5, rotation: 270 },
    { name: 'sq_09', x: 3, y: 5, rotation: 270 },
    { name: 'sq_06', x: 4, y: 5, rotation: 270 },
    // 6è¡Œç›®
    { name: 'sq_02', x: 3, y: 6, rotation: 270 },
  ];
  
  // ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’é…ç½®ï¼ˆtri_00_a ~ tri_07_c ã®24å€‹ï¼‰
  // position: 'top', 'right', 'bottom', 'left' ã§æ­£æ–¹å½¢1å€‹åˆ†ã®é ˜åŸŸå†…ã®ä½ç½®ã‚’æŒ‡å®š
  layout.triangles = [
    // x:2, y:0 ã®é ˜åŸŸ
    { name: 'tri_02_c', x: 2, y: 0, position: 'right', rotation: 0 },
    { name: 'tri_02_a', x: 2, y: 0, position: 'bottom', rotation: 0 },
    { name: 'tri_02_b', x: 2, y: 0, position: 'left', rotation: 0 },
    // x:0, y:2 ã®é ˜åŸŸ
    { name: 'tri_02_c', x: 0, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_02_a', x: 0, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_02_b', x: 0, y: 2, position: 'bottom', rotation: 0 },
    // x:4, y:0 ã®é ˜åŸŸ
    { name: 'tri_00_b', x: 4, y: 0, position: 'right', rotation: 0 },
    { name: 'tri_00_c', x: 4, y: 0, position: 'bottom', rotation: 0 },
    { name: 'tri_00_a', x: 4, y: 0, position: 'left', rotation: 0 },
    // x:6, y:2 ã®é ˜åŸŸ
    { name: 'tri_00_b', x: 6, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_00_c', x: 6, y: 2, position: 'left', rotation: 0 },
    { name: 'tri_00_a', x: 6, y: 2, position: 'top', rotation: 0 },
    // å·¦ä¸Šï¼ˆx:2, y:2 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_03_c', x: 2, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_03_a', x: 2, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_03_b', x: 2, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_03_c', x: 2, y: 2, position: 'left', rotation: 0 },
    // å³ä¸Šï¼ˆx:4, y:2 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_01_a', x: 4, y: 2, position: 'top', rotation: 0 },
    { name: 'tri_01_a', x: 4, y: 2, position: 'right', rotation: 0 },
    { name: 'tri_01_b', x: 4, y: 2, position: 'bottom', rotation: 0 },
    { name: 'tri_01_c', x: 4, y: 2, position: 'left', rotation: 0 },
    // å·¦ä¸‹ï¼ˆx:2, y:4 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_07_b', x: 2, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_07_c', x: 2, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_07_a', x: 2, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_07_a', x: 2, y: 4, position: 'left', rotation: 0 },
    // å³ä¸‹ï¼ˆx:4, y:4 ã®é ˜åŸŸã«4å€‹é…ç½®ï¼‰
    { name: 'tri_05_b', x: 4, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_05_c', x: 4, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_05_c', x: 4, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_05_a', x: 4, y: 4, position: 'left', rotation: 0 },
    // x:2, y:6 ã®é ˜åŸŸ
    { name: 'tri_06_b', x: 2, y: 6, position: 'left', rotation: 0 },
    { name: 'tri_06_c', x: 2, y: 6, position: 'top', rotation: 0 },
    { name: 'tri_06_a', x: 2, y: 6, position: 'right', rotation: 0 },
    // x:0, y:4 ã®é ˜åŸŸ
    { name: 'tri_06_b', x: 0, y: 4, position: 'top', rotation: 0 },
    { name: 'tri_06_c', x: 0, y: 4, position: 'right', rotation: 0 },
    { name: 'tri_06_a', x: 0, y: 4, position: 'bottom', rotation: 0 },
    // x:4, y:6 ã®é ˜åŸŸ
    { name: 'tri_04_c', x: 4, y: 6, position: 'left', rotation: 0 },
    { name: 'tri_04_a', x: 4, y: 6, position: 'top', rotation: 0 },
    { name: 'tri_04_b', x: 4, y: 6, position: 'right', rotation: 0 },
    // x:6, y:4 ã®é ˜åŸŸ
    { name: 'tri_04_c', x: 6, y: 4, position: 'bottom', rotation: 0 },
    { name: 'tri_04_a', x: 6, y: 4, position: 'left', rotation: 0 },
    { name: 'tri_04_b', x: 6, y: 4, position: 'top', rotation: 0 },
  ];
  
  return layout;
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠé–¢æ•°
function getRhombicuboctaLayout(patternNumber){
  if(patternNumber === 1){
    return getRhombicuboctaLayout1();
  } else if(patternNumber === 2){
    return getRhombicuboctaLayout2();
  } else {
    console.warn('ä¸æ˜ãªãƒ‘ã‚¿ãƒ¼ãƒ³ç•ªå·:', patternNumber, 'ãƒ‘ã‚¿ãƒ¼ãƒ³1ã‚’ä½¿ç”¨ã—ã¾ã™');
    return getRhombicuboctaLayout1();
  }
}

// å±•é–‹å›³ã‚’ç”Ÿæˆã—ã¦ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
function generateLayout(faces){
  const layout = getRhombicuboctaLayout(1); // ãƒ‘ã‚¿ãƒ¼ãƒ³1ã‚’ä½¿ç”¨
  
  // faceSizeã‚’å–å¾—ï¼ˆæ­£æ–¹å½¢ã®å®Ÿéš›ã®æç”»ã‚µã‚¤ã‚ºï¼‰
  const squareFace = faces.find(f => f.name.startsWith('sq_'));
  if(!squareFace){
    alert('æ­£æ–¹å½¢é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    return;
  }
  
  // æ­£æ–¹å½¢ã®å®Ÿéš›ã®æç”»é ˜åŸŸã‚’æ¤œå‡º
  const bounds = detectDrawingBounds(squareFace.canvas);
  const faceSize = bounds.width; // å®Ÿéš›ã®æ­£æ–¹å½¢ã®ã‚µã‚¤ã‚º
  
  // å…ƒã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºï¼ˆ7x7ãƒã‚¹ï¼‰
  const originalCanvasSize = faceSize * 7;
  
  // å›è»¢å¾Œã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º
  // 5x5ãƒã‚¹ã‚’åŸºæº–ã«45åº¦å›è»¢å¾Œã®å¯¾è§’ç·šã‚’æ–°ã—ã„å¹…ãƒ»é«˜ã•ã¨ã™ã‚‹ï¼ˆåˆ‡ã‚Šä¸Šã’ã¦æ•´æ•°ã«ã™ã‚‹ï¼‰
  const rotatedCanvasSize = Math.ceil(Math.sqrt(2) * faceSize * 5);
  
  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆ7x7ã€éš™é–“ãªã—ï¼‰
  const canvasWidth = faceSize * 7;
  const canvasHeight = faceSize * 7;
  
  // ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆï¼ˆ7x7ãƒã‚¹ã‚’æç”»ç”¨ï¼‰
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = originalCanvasSize;
  tempCanvas.height = originalCanvasSize;
  const tempCtx = tempCanvas.getContext('2d');

  // èƒŒæ™¯ã‚’ç™½ã«ï¼ˆä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼‰
  tempCtx.fillStyle = '#ffffff';
  tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

  // æœ€çµ‚çš„ãªè¡¨ç¤ºç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆå›è»¢å¾Œã®ã‚µã‚¤ã‚ºï¼‰
  const canvas = el.layoutCanvas;
  canvas.width = rotatedCanvasSize;
  canvas.height = rotatedCanvasSize;
  const ctx = canvas.getContext('2d');

  // èƒŒæ™¯ã‚’ç™½ã«ï¼ˆæœ€çµ‚ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼‰
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã‚’æç”»
  layout.triangles.forEach(item => {
    const face = faces.find(f => f.name === item.name);
    if(!face) return;
    
    // ã“ã®é¢ã®æç”»é ˜åŸŸã‚’æ¤œå‡º
    const faceBounds = detectDrawingBounds(face.canvas);
    const triSize = faceBounds.width; // ä¸‰è§’å½¢ã®å…ƒã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º
    
    // ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã®å¹¾ä½•å­¦çš„ç‰¹æ€§ï¼š
    // æ–œè¾º = faceSizeï¼ˆæ­£æ–¹å½¢ã®1è¾ºï¼‰
    // å…ƒç”»åƒå†…ã§ã®å®Ÿéš›ã®æ–œè¾ºã®é•·ã•ã‚’è¨ˆç®—
    // å…ƒç”»åƒã¯ triSize ã®æ­£æ–¹å½¢ã«åã¾ã£ã¦ã„ã‚‹
    // å®Ÿéš›ã®ä¸‰è§’å½¢ã®æ–œè¾ºã‚’ faceSize ã«ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹
    const scale = faceSize / triSize;
    
    // åŸºæº–åº§æ¨™ï¼ˆæ­£æ–¹å½¢ã®ä¸­å¿ƒï¼‰
    const centerX = item.x * faceSize + faceSize / 2;
    const centerY = item.y * faceSize + faceSize / 2;
    
    // position ã«å¿œã˜ãŸå›è»¢è§’åº¦
    let posRotation = 0;
    
    switch(item.position){
      case 'top':
        // ä¸Šå´ï¼šæ–œè¾ºã‚’ä¸Šè¾ºã«é…ç½® â†’ å…ƒç”»åƒã‚’180åº¦å›è»¢
        posRotation = 180;
        break;
      case 'right':
        // å³å´ï¼šæ–œè¾ºã‚’å³è¾ºã«é…ç½® â†’ å…ƒç”»åƒã‚’270åº¦å›è»¢
        posRotation = 270;
        break;
      case 'bottom':
        // ä¸‹å´ï¼šæ–œè¾ºã‚’ä¸‹è¾ºã«é…ç½® â†’ å…ƒç”»åƒã®ã¾ã¾
        posRotation = 0;
        break;
      case 'left':
        // å·¦å´ï¼šæ–œè¾ºã‚’å·¦è¾ºã«é…ç½® â†’ å…ƒç”»åƒã‚’90åº¦å›è»¢
        posRotation = 90;
        break;
    }
    
    // åˆè¨ˆå›è»¢è§’åº¦
    const totalRotation = (posRotation + (item.rotation || 0)) % 360;
    
    tempCtx.save();
    
    // æ­£æ–¹å½¢ã®ä¸­å¿ƒã«ç§»å‹•
    tempCtx.translate(centerX, centerY);
    
    // å›è»¢
    tempCtx.rotate(totalRotation * Math.PI / 180);
    
    // ç›´è§’äºŒç­‰è¾ºä¸‰è§’å½¢ã®æç”»
//    const drawSize = triSize * scale;
    const drawSize = faceSize + 4;	// æ­£æ–¹å½¢ã‚µã‚¤ã‚ºï¼‹ãƒãƒ¼ã‚¸ãƒ³(å‘¨å›²2ãƒ”ã‚¯ã‚»ãƒ«åˆ†)
    tempCtx.drawImage(
      face.canvas,
      faceBounds.x, faceBounds.y, faceBounds.width, faceBounds.height, // å…ƒç”»åƒã®åˆ‡ã‚Šå‡ºã—é–‹å§‹ä½ç½®ã¨ã‚µã‚¤ã‚º
      -drawSize/2, 0, drawSize, drawSize/2 // é…ç½®å…ˆã§ã®ä½ç½®ã¨ã‚µã‚¤ã‚º
    );
    
    tempCtx.restore();
  });
  
  // æ­£æ–¹å½¢ã‚’æç”»
  layout.squares.forEach(item => {
    const face = faces.find(f => f.name === item.name);
    if(!face) return;
    
    // ã“ã®é¢ã®æç”»é ˜åŸŸã‚’æ¤œå‡º
    const faceBounds = detectDrawingBounds(face.canvas);
    
    // ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã‚’è¨ˆç®—ï¼ˆéš™é–“ãªã—ï¼‰
    const px = item.x * faceSize;
    const py = item.y * faceSize;
    
    // å›è»¢ãŒã‚ã‚‹å ´åˆã¯å›è»¢å‡¦ç†ã‚’é©ç”¨
    if(item.rotation && item.rotation !== 0){
      tempCtx.save(); // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
      
      // å›è»¢ã®ä¸­å¿ƒç‚¹ï¼ˆé…ç½®å…ˆã®ä¸­å¤®ï¼‰ã«ç§»å‹•
      tempCtx.translate(px + faceSize / 2, py + faceSize / 2);
      
      // å›è»¢ï¼ˆåº¦æ•°æ³•â†’ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
      tempCtx.rotate(item.rotation * Math.PI / 180);
      
      // å›è»¢å¾Œã®æç”»ä½ç½®ã‚’èª¿æ•´ï¼ˆä¸­å¿ƒãŒåŸç‚¹ã«ãªã£ã¦ã„ã‚‹ã®ã§å·¦ä¸Šã«æˆ»ã™ï¼‰
      tempCtx.translate(-faceSize / 2, -faceSize / 2);
      
      // æç”»é ˜åŸŸã ã‘ã‚’åˆ‡ã‚Šå‡ºã—ã¦é…ç½®
      tempCtx.drawImage(
        face.canvas,
        faceBounds.x, faceBounds.y, faceBounds.width, faceBounds.height,
        0, 0, faceBounds.width, faceBounds.height
      );
      
      tempCtx.restore(); // çŠ¶æ…‹ã‚’å¾©å…ƒ
    } else {
      // å›è»¢ãªã—ã®å ´åˆã¯å¾“æ¥é€šã‚Š
      tempCtx.drawImage(
        face.canvas,
        faceBounds.x, faceBounds.y, faceBounds.width, faceBounds.height,
        px, py, faceBounds.width, faceBounds.height
      );
    }
  });

  // ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’45åº¦å›è»¢ã•ã›ã¦æœ€çµ‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
  // æœ€çµ‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸­å¿ƒã«ç§»å‹•
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  // 45åº¦å›è»¢
  ctx.rotate(45 * Math.PI / 180);
  // ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä¸­å¿ƒã‚’åŸºæº–ã«æç”»
  ctx.drawImage(
    tempCanvas,
    -tempCanvas.width / 2,
    -tempCanvas.height / 2
  );
  ctx.restore();
  
  // æœ€çµ‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å¤–å‘¨ã«å¢ƒç•Œç·šã‚’æç”»
  ctx.strokeStyle = '#000000'; // é»’è‰²
  ctx.lineWidth = 2 * 2; // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã«å¹…2ãƒ”ã‚¯ã‚»ãƒ«ã§æç”»ã™ã‚‹ãŸã‚ã«ã€2å€ã—ã¦è¨­å®šã™ã‚‹
  ctx.strokeRect(0, 0, canvas.width, canvas.height);
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
  el.layoutWrap.style.display = 'block';
  const triCount = layout.triangles.length;
  el.layoutInfo.textContent = `å±•é–‹å›³ï¼š${canvasWidth} Ã— ${canvasHeight} pxï¼ˆ18æ­£æ–¹å½¢ + ${triCount}ä¸‰è§’å½¢ï¼‰`;
  
  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
  el.layoutDownload.style.display = 'inline-block';
  el.layoutDownload.onclick = async () => {
    const mime = el.fmt.value;
    const quality = parseFloat(el.qualityRange.value);
    const ext = extFromMime(mime);
    const prefix = el.prefix.value || '';
    const blob = await canvasToBlob(canvas, mime, quality);
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${prefix}rhombicubocta_layout.${ext}`;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(url), 10000);
  };
}

el.layoutBtn.addEventListener('click', ()=>{
  if(!lastFaces.length){ alert('å…ˆã«å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚'); return; }
  if(lastPoly !== 'rhombicubocta'){ 
    alert('å±•é–‹å›³ä½œæˆã¯ç¾åœ¨ã€æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚'); 
    return; 
  }
  
  // å±•é–‹å›³ç”Ÿæˆå‡¦ç†ï¼ˆæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿè£…ï¼‰
  generateLayout(lastFaces);
});

</script>
</body>
</html>
