<!--
/**
 * 360 Image DEEP HACK Equi2Poly3
 * 
 * @description 360ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ã‚’å¤šé¢ä½“ã«å¤‰æ›ï¼‰
 * @author ã„ã‘ã ã˜ã‚…ã‚“ã˜ (enhanced by Claude, updated by ChatGPT)
 * @version 1.1
 * @date 20250831
 * @license Public Domain - å†é…å¸ƒã€æ”¹å¤‰è‡ªç”±ã€ä¸€åˆ‡ã®åˆ¶é™ãªã—
 * @disclaimer 
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 *   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DAMAGES ARISING FROM THE USE OF THIS SOFTWARE.
 *   ã“ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ç„¡ä¿è¨¼ã§æä¾›ã•ã‚Œã€ä½œè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
 *   - ãƒ¡ãƒ¢ãƒªä¸è¶³ã«ã‚ˆã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
 *   - å‡¦ç†çµæœã®å“è³ªã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“
 *   - é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã¯äº‹å‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ãã ã•ã„
 *   - æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½¿ç”¨ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™
 *
 * æœ¬ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ JSZip (https://stuk.github.io/jszip/)(MIT License) ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™
 * 
 * v 1.0 ãƒªãƒªãƒ¼ã‚¹
 * v 1.1 æ­£äºŒåé¢ä½“ã®å„é¢ã®å½¢çŠ¶ã‚’ä¿®æ­£ï¼ˆï¼‰
 * Acknowledgements
 * æ­£äºŒåé¢ä½“ã®å„é¢å½¢çŠ¶ã®æ¤œè¨¼ãƒ»æ”¹å–„ã«å”åŠ›ã„ãŸã ã„ãŸ asari ã•ã‚“ã«æ„Ÿè¬ã—ã¾ã™ ğŸ™
* CHANGELOG 20250906 
 *
 * v 1.2 ãƒ©ãƒ³ã‚¿ã‚¤ãƒ åè»¢ã¨ä¸Šä¸‹é¢ã®å‘ãèª¿æ•´ã€å±•é–‹ç·šæç”»ã€ZIP/ã‚¿ã‚¤ãƒ«å¼·åŒ–ï¼ˆ2025-09-06ï¼‰
 *  - [å¤‰æ›å…ƒã®æ‰±ã„] å¤‰æ›å®Ÿè¡Œæ™‚ã«ã ã‘å‡¦ç†åˆ†å²ã€‚æ­£å…­é¢ä½“ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ãã®ã¾ã¾ä½¿ç”¨ã€‚
 *     æ­£äºŒåé¢ä½“ / åˆ‡é ‚äºŒåé¢ä½“ã¯ã€å®Ÿè¡Œç›´å‰ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ã€Œæ°´å¹³åè»¢ã€ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã§ç½®æ›ã€‚
 *     (createHorizontallyFlippedCanvas, originalImageã®å°å…¥ã§å‰¯ä½œç”¨ã‚’å›é¿)
 *  - [ãƒã‚°ä¿®æ­£] fileé¸æŠã§èª­ã¿è¾¼ã‚“ã å ´åˆã«ã‚‚ originalImage ã‚’ç¢ºå®Ÿã«ã‚»ãƒƒãƒˆï¼ˆD&Dã¨æŒ™å‹•ã‚’çµ±ä¸€ï¼‰ã€‚
 *  - [ç´™ã®å±•é–‹å›³å‘ã‘] æ­£å…­é¢ä½“ã®ä¸Šä¸‹é¢ã®å‡ºåŠ›ã‚’å°åˆ·çµ„ã¿ç«‹ã¦ç”¨ã«æœ€é©åŒ–ã€‚
 *       poly_ny(-Y).png : å·¦å³åè»¢ â†’ æ™‚è¨ˆå›ã‚Šã«90Â°å›è»¢
 *       poly_py(+Y).png : å·¦å³åè»¢ â†’ åæ™‚è¨ˆå›ã‚Šã«90Â°å›è»¢
 *     (flipHThenRotate90 ã‚’ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã§é©ç”¨ã€‚ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¼ã¯æœªå¤‰æ›´)
 *  - [æ–°æ©Ÿèƒ½] ã€Œå±•é–‹ç·šã‚’ã‚¨ã‚¯ã‚¤ç”»åƒã«æãã€å‡ºåŠ›ã‚’è¿½åŠ ï¼ˆè‰²/å¤ªã•æŒ‡å®šå¯ï¼‰ã€‚
 *     å¤šé¢ä½“ã®å…¨ã‚¨ãƒƒã‚¸ã‚’çƒé¢è£œé–“ã§ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã€çµŒåº¦ã¾ãŸãã‚’è€ƒæ…®ã—ã¦equirectã«æç”»ãƒ»ä¿å­˜ã€‚
 *  - [å‡ºåŠ›å¼·åŒ–] ç”Ÿæˆé¢ã®ä¸€æ‹¬ZIPä¿å­˜(JSZip)ï¼1æšã‚¿ã‚¤ãƒ«ç”Ÿæˆã¨ä¿å­˜ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä»˜ãï¼‰ã‚’æ•´å‚™ã€‚
 *  - [UI/å¾®ä¿®æ­£] å“è³ªãƒ©ãƒ™ãƒ«ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã€ã‚¢ãƒ©ãƒ¼ãƒˆæ–‡è¨€èª¿æ•´ã€å†…éƒ¨é–¢æ•°ã®æ•´ç†ã€‚
 *
 * æ—¢çŸ¥ã®æ³¨æ„:
 *  - å¤§å®¹é‡ç”»åƒã§ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¢—ãˆã¾ã™ã€‚ä¿å­˜å‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã‚µã‚¤ã‚ºã‚’ã”ç¢ºèªãã ã•ã„ã€‚
 *  - equirectã®æ¥µä»˜è¿‘ã§ã¯ç”»ç´ å¯†åº¦ã®é–¢ä¿‚ã§ã«ã˜ã¿ãŒè¦‹ãˆã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼ˆä»•æ§˜ï¼‰ã€‚
 *
 * ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ:
 *  - Code & Design: ã„ã‘ã ã˜ã‚…ã‚“ã˜
 *  - Enhanced with: Claude / ChatGPTï¼ˆå®Ÿè£…ææ¡ˆãƒ»ãƒã‚°ä¿®æ­£ãƒ»æœ€é©åŒ–ï¼‰
 *  - Third-party: JSZip (MIT)
 */
-->

<!DOCTYPE html>
<html lang="ja">
<head>
<!-- è¿½åŠ ï¼šZIPç”Ÿæˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Equirect â†’ Cube / Icosahedron / Truncated Icosahedron Exporter v1.2</title>
<style>
  :root{
    --bg1:#1e3c72; --bg2:#2a5298;
    --panel: rgba(255,255,255,0.1);
    --accent:#4CAF50;
  }
  body{
    margin:0; padding:20px; color:#fff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    background:linear-gradient(135deg,var(--bg1),var(--bg2));
  }
  .container{ max-width:1200px; margin:0 auto; }
  h1{ margin:0 0 12px; font-size:22px; }
  .row{ display:grid; gap:12px; grid-template-columns: 1fr; }
  @media(min-width:900px){ .row{ grid-template-columns: 1fr 1fr; } }
  .card{
    background:var(--panel); border:1px solid rgba(255,255,255,0.2);
    border-radius:16px; padding:16px; backdrop-filter: blur(8px);
  }
  label{ display:block; font-size:14px; opacity:0.9; margin-bottom:6px; }
  input[type="number"], select, input[type="text"]{
    width:100%; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.25);
    background:rgba(0,0,0,0.2); color:#fff; outline:none;
  }
  .range-row{ display:flex; align-items:center; gap:8px; }
  input[type="range"]{ flex:1; }
  .btn{
    background:var(--accent); border:none; color:#fff; padding:10px 16px; border-radius:12px; cursor:pointer;
    font-weight:600; box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  }
  .btn.secondary{ background:#2196F3; }
  .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.35); }
  .upload-area{
    border:2px dashed var(--accent); border-radius:12px; padding:14px; text-align:center;
    background:rgba(255,255,255,0.08);
  }
  .upload-area.dragover{ border-color:#2196F3; background:rgba(255,255,255,0.12); }
  .faces{
    display:flex; flex-wrap:wrap; gap:16px; align-items:flex-start;
  }
  .face{
    background:rgba(0,0,0,0.2); border-radius:12px; padding:10px; text-align:center; border:1px solid rgba(255,255,255,0.15);
  }
  .face canvas{ display:block; max-width:256px; height:auto; border-radius:8px; }
  .face p{ margin:8px 0 8px; font-size:12px; opacity:0.9; }
  .grid-preview{ max-width:100%; border-radius:12px; }
  .mini{ font-size:12px; opacity:0.85; }
  .split{ display:flex; gap:10px; flex-wrap:wrap; }
</style>
</head>
<body>
<div class="container">
  <h1>360ã‚¨ã‚¯ã‚¤ â†’ æ­£å…­é¢ä½“ï¼æ­£äºŒåé¢ä½“ï¼ã‚«ã‚¯ã‚«ã‚¯âš½ï¸ã‚µãƒƒã‚«ãƒ¼ãƒœãƒ¼ãƒ«ãƒ»åˆ‡é ‚äºŒåé¢ä½“ã€€å¤‰æ› v1.2 </h1>

  <div class="row">
    <!-- å…¥åŠ› -->
    <div class="card">
      <h2 style="margin-top:0;font-size:18px;">1) å…¥åŠ›</h2>
      <div class="upload-area" id="uploadArea">
        <p class="mini">ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ— / ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰é¸æŠ</p>
        <input type="file" id="fileInput" accept="image/*" />
      </div>
      <div id="inputInfo" class="mini" style="margin-top:8px; opacity:.8;">æœªèª­ã¿è¾¼ã¿</div>
    </div>

    <!-- è¨­å®š -->
    <div class="card">
      <h2 style="margin-top:0;font-size:18px;">2) è¨­å®š</h2>
      <div class="split">
        <div style="flex:1; min-width:220px;">
          <label>å¤šé¢ä½“ã®ç¨®é¡</label>
          <select id="polyType">
            <option value="cube">æ­£å…­é¢ä½“ï¼ˆ6æ­£æ–¹ï¼‰</option>
            <option value="icosa">æ­£äºŒåé¢ä½“ï¼ˆ20ä¸‰è§’ï¼‰</option>
            <option value="truncated">åˆ‡é ‚äºŒåé¢ä½“ï¼ˆ12äº”è§’+20å…­è§’ï¼‰</option>
            <option value="rhombicubocta">æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼ˆ8ä¸‰è§’+18æ­£æ–¹ï¼‰</option>
          </select>
        </div>
        <div style="flex:1; min-width:220px;">
          <label>é¢ã‚µã‚¤ã‚ºï¼ˆæ¨å¥¨ï¼šã‚­ãƒ¥ãƒ¼ãƒ–=å¹…/4ã€äºŒåé¢/åˆ‡é ‚=å¹…/6ã€œ/8ï¼‰</label>
          <input type="number" id="faceSize" min="64" max="4096" step="1" value="512" />
        </div>
      </div>

      <div id="truncRow" style="margin-top:10px; display:none;">
        <label>åˆ‡é ‚ç‡ tï¼ˆ0.25ã€œ0.4 ãŒå®Ÿç”¨ï¼‰</label>
        <div class="range-row">
          <input type="range" id="truncRange" min="0.20" max="0.45" step="0.005" value="0.333" />
          <input type="number" id="truncNumber" min="0.20" max="0.45" step="0.001" value="0.333" style="width:100px;" />
        </div>
      </div>

      <div style="margin-top:14px;">
        <button class="btn" id="runBtn">å¤‰æ›ã‚’å®Ÿè¡Œ</button>
        <button class="btn ghost" id="clearBtn">ã‚¯ãƒªã‚¢</button>
      </div>
    </div>
  </div>

  <!-- å‡ºåŠ› -->
  <div class="card" style="margin-top:14px;">
    <h2 style="margin-top:0;font-size:18px;">3) å‡ºåŠ›å½¢å¼</h2>
    <div class="split">
      <div style="flex:1; min-width:220px;">
        <label>ä¿å­˜å½¢å¼</label>
        <select id="fmt">
          <option value="image/png">PNGï¼ˆå¯é€†ï¼‰</option>
          <option value="image/jpeg">JPEGï¼ˆéå¯é€†ï¼‰</option>
          <option value="image/webp">WebPï¼ˆãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œæ™‚ï¼‰</option>
        </select>
      </div>
      <div style="flex:1; min-width:220px;">
        <label>å“è³ªï¼ˆJPEG/WebPã®ã¿æœ‰åŠ¹ï¼‰</label>
        <div class="range-row">
          <input type="range" id="qualityRange" min="0.5" max="1" value="0.92" step="0.01" />
          <span id="qualityLabel" class="mini">0.92</span>
        </div>
      </div>
      <div style="flex:1; min-width:220px;">
        <label>å‡ºåŠ›åãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹</label>
        <input type="text" id="prefix" value="poly_" />
      </div>
    </div>

    <div style="margin-top:12px;">
      <button class="btn secondary" id="dlAllBtn">é¢ã‚’ä¸€æ‹¬ZIPä¿å­˜</button>
      <button class="btn" id="gridBtn">1æšã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆ</button>
      <a id="gridDownload" class="btn ghost" style="display:none;">ã‚¿ã‚¤ãƒ«ç”»åƒã‚’ä¿å­˜</a>
      <div id="gridInfo" class="mini" style="margin-top:8px; opacity:.85;"></div>
    </div>
    
    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
  <button class="btn ghost" id="drawGuideBtn">å±•é–‹ç·šã‚’ã‚¨ã‚¯ã‚¤ç”»åƒã«æã</button>
  <label class="mini" style="margin:0;">è‰² <input type="color" id="guideColor" value="#ff2d55" style="vertical-align:middle;"></label>
  <label class="mini" style="margin:0;">å¤ªã•(px) <input type="number" id="guideWidth" value="2" min="1" max="8" step="1" style="width:70px;vertical-align:middle;"></label>
</div>

    
  </div>
  
  

  <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
  <div class="card" style="margin-top:14px;">
    <h2 style="margin-top:0;font-size:18px;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
    <div id="faces" class="faces"></div>
    <div id="gridWrap" style="margin-top:16px; display:none;">
      <p class="mini">ã‚¿ã‚¤ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼š</p>
      <canvas id="gridCanvas" class="grid-preview"></canvas>
    </div>
  </div>
</div>

<script>
/* ============================= å…±æœ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ============================= */
// cubeã®ç‰¹å®šã«äºŒé¢ãŒä¿®æ­£ã®ãŸã‚è¿½åŠ  20250906+
// æ°´å¹³åè»¢ã—ã¦ã‹ã‚‰90åº¦å›è»¢ï¼ˆdir: 'cw' | 'ccw'ï¼‰
function flipHThenRotate90(srcCanvas, dir='cw'){
  const w = srcCanvas.width, h = srcCanvas.height; // æ­£æ–¹å½¢å‰æ
  // 1) æ°´å¹³åè»¢
  const flipped = document.createElement('canvas');
  flipped.width = w; flipped.height = h;
  const fctx = flipped.getContext('2d');
  fctx.translate(w, 0);
  fctx.scale(-1, 1);
  fctx.drawImage(srcCanvas, 0, 0);

  // 2) 90åº¦å›è»¢
  const out = document.createElement('canvas');
  out.width = w; out.height = h; // æ­£æ–¹å½¢ãªã®ã§åŒã˜
  const octx = out.getContext('2d');
  if (dir === 'cw'){          // æ™‚è¨ˆå›ã‚Š
    octx.translate(w, 0);
    octx.rotate(Math.PI / 2);
  } else {                    // åæ™‚è¨ˆå›ã‚Š
    octx.translate(0, h);
    octx.rotate(-Math.PI / 2);
  }
  octx.drawImage(flipped, 0, 0);
  return out;
}

// æ°´å¹³åè»¢ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è¿”ã™ï¼ˆimg/canvas ã©ã¡ã‚‰ã§ã‚‚OKï¼‰ 20250906+ for å¤šé‡é¢ä½“ã§ã®åè»¢ã®ãŸã‚
function createHorizontallyFlippedCanvas(img){
  const c = document.createElement('canvas');
  c.width = img.width; c.height = img.height;
  const ctx = c.getContext('2d');
  ctx.translate(c.width, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0);
  return c; // width/heightã‚’æŒã¤ã®ã§æ—¢å­˜ã®å‡¦ç†ã«ãã®ã¾ã¾æ¸¡ã›ã‚‹
}


function dirToLonLat(x,y,z){
  const r = Math.hypot(x,y,z);
  const lat = Math.asin(y / r);
  const lon = Math.atan2(x, z);
  return {lat, lon};
}

// ãƒãƒªã‚»ãƒ³åˆ¤å®šï¼šå†…éƒ¨ãªã‚‰ {inside:true,u,v,w} ã‚’è¿”ã™ï¼ˆæ­£äºŒåé¢ä½“æç”»ã§ä½¿ç”¨ï¼‰
function pointInTri(px, py, ax, ay, bx, by, cx, cy){
  const v0x = cx - ax, v0y = cy - ay;
  const v1x = bx - ax, v1y = by - ay;
  const v2x = px - ax, v2y = py - ay;
  const den = v0x*v1y - v1x*v0y;
  const u = (v2x*v1y - v1x*v2y) / den;
  const v = (v0x*v2y - v2x*v0y) / den;
  const w = 1 - u - v;
  const inside = (u >= 0 && v >= 0 && w >= 0);
  return {inside, u, v, w};
}

// 3Dä¸‰é ‚ç‚¹ã®ç·šå½¢â†’æ­£è¦åŒ–ï¼ˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«å–å¾—ï¼‰
function baryToDir(u,v,w, A,B,C){
  const x = u*A[0] + v*B[0] + w*C[0];
  const y = u*A[1] + v*B[1] + w*C[1];
  const z = u*A[2] + v*B[2] + w*C[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

// ã‚¨ã‚¯ã‚¤ç”»åƒã‹ã‚‰åŒç·šå½¢ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆçµŒåº¦ãƒ©ãƒƒãƒ—ãƒ»ç·¯åº¦ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
function bilinearInterpolateEquirect(eData, x, y, w, h){
  x = ((x % w) + w) % w;
  y = Math.max(0, Math.min(h - 1, y));

  const x0 = Math.floor(x), x1 = (x0 + 1) % w;
  const y0 = Math.floor(y), y1 = Math.min(h - 1, y0 + 1);
  const dx = x - x0, dy = y - y0;

  const idx = (xx,yy)=> (yy*w + xx) * 4;

  const i00 = idx(x0,y0), i10 = idx(x1,y0), i01 = idx(x0,y1), i11 = idx(x1,y1);
  const c00 = [eData[i00], eData[i00+1], eData[i00+2], eData[i00+3]];
  const c10 = [eData[i10], eData[i10+1], eData[i10+2], eData[i10+3]];
  const c01 = [eData[i01], eData[i01+1], eData[i01+2], eData[i01+3]];
  const c11 = [eData[i11], eData[i11+1], eData[i11+2], eData[i11+3]];

  const c0 = c00.map((v,i)=> v*(1-dx) + c10[i]*dx);
  const c1 = c01.map((v,i)=> v*(1-dx) + c11[i]*dx);
  const c  = c0.map((v,i)=> v*(1-dy) + c1[i]*dy);
  return c;
}

// 2Dãƒãƒªã‚´ãƒ³ã®å¹³å‡è¾ºé•·ï¼ˆéš£æ¥ç‚¹è·é›¢ã®å¹³å‡ï¼‰
function avgEdgeLen2D(poly2){
  let s = 0;
  for(let i=0;i<poly2.length;i++){
    const a = poly2[i], b = poly2[(i+1)%poly2.length];
    s += Math.hypot(b[0]-a[0], b[1]-a[1]);
  }
  return s / poly2.length;
}


/* ============================= æ­£äºŒåé¢ä½“ ============================= */
function icosahedronData(){
  const PHI = (1 + Math.sqrt(5)) / 2;
  const V = [
    [-1,  PHI, 0], [ 1,  PHI, 0], [-1, -PHI, 0], [ 1, -PHI, 0],
    [ 0, -1,  PHI], [ 0,  1,  PHI], [ 0, -1, -PHI], [ 0,  1, -PHI],
    [ PHI, 0, -1], [ PHI, 0,  1], [-PHI, 0, -1], [-PHI, 0,  1],
  ].map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  const F = [
    [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
    [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
    [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
    [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1],
  ];
  return {V,F};
}

/* ============================= æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ ============================= */
function rhombicuboctahedronData(){
  // æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ã®24é ‚ç‚¹ï¼ˆã‚ˆã‚Šæ­£ç¢ºãªåº§æ¨™ï¼‰
  const a = 1.0; // åŸºæº–é•·
  const b = Math.sqrt(2) - 1; // â‰ˆ 0.414
  
  const vertices = [
    // 8å€‹ã®ç«‹æ–¹ä½“é ‚ç‚¹ã«è¿‘ã„ç‚¹
    [ a,  a,  b], [ a, -a,  b], [-a,  a,  b], [-a, -a,  b], // 0-3
    [ a,  a, -b], [ a, -a, -b], [-a,  a, -b], [-a, -a, -b], // 4-7
    // 8å€‹ã®æ­£å…«é¢ä½“é ‚ç‚¹ã«è¿‘ã„ç‚¹
    [ a,  b,  a], [ a,  b, -a], [-a,  b,  a], [-a,  b, -a], // 8-11
    [ a, -b,  a], [ a, -b, -a], [-a, -b,  a], [-a, -b, -a], // 12-15
    // 8å€‹ã®è¿½åŠ ç‚¹
    [ b,  a,  a], [ b,  a, -a], [ b, -a,  a], [ b, -a, -a], // 16-19
    [-b,  a,  a], [-b,  a, -a], [-b, -a,  a], [-b, -a, -a]  // 20-23
  ];
  
  // æ­£è¦åŒ–
  const V = vertices.map(([x,y,z])=>{
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv, y*inv, z*inv];
  });
  
  // ä¸‰è§’å½¢é¢ï¼ˆ8å€‹ï¼‰ - æ­£å…«é¢ä½“ã®é¢ã«å¯¾å¿œ
  const triangles = [
    [0, 8, 16], [1, 12, 18], [2, 10, 20], [3, 14, 22],
    [4, 9, 17], [5, 13, 19], [6, 11, 21], [7, 15, 23]
  ];
  
  // æ­£æ–¹å½¢é¢ï¼ˆ18å€‹ï¼‰ - ç«‹æ–¹ä½“ã®é¢ã‚’åˆ‡ã‚Šå–ã£ãŸå½¢
  const squares = [
    // ä¸Šä¸‹é¢
    [0, 2, 10, 8], [1, 3, 14, 12], [4, 6, 11, 9], [5, 7, 15, 13],
    // å‰å¾Œé¢  
    [0, 1, 18, 16], [2, 3, 22, 20], [4, 5, 19, 17], [6, 7, 23, 21],
    // å·¦å³é¢
    [0, 4, 17, 16], [1, 5, 19, 18], [2, 6, 21, 20], [3, 7, 23, 22],
    // ä¸­é–“é¢
    [8, 10, 11, 9], [12, 14, 15, 13], [16, 17, 19, 18], 
    [20, 21, 23, 22], [8, 9, 17, 16], [10, 11, 21, 20]
  ];
  
  return {V, triangles, squares};
}

function renderIcosaFace(equirectData, ew, eh, A, B, C, faceSize){
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  // æ­£ä¸‰è§’å½¢ï¼ˆside=faceSizeï¼‰ã‚’æ­£æ–¹å½¢ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã«å†…æ¥ã•ã›ã‚‹
  const side = faceSize;
  const h = side * Math.sqrt(3) / 2;               // æ­£ä¸‰è§’å½¢ã®é«˜ã•
  const marginY = Math.max(0, (faceSize - h) / 2); // å‚ç›´æ–¹å‘ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°

  // é ‚ç‚¹åº§æ¨™ï¼ˆä¸Šï¼šAã€ä¸‹å·¦ï¼šBã€ä¸‹å³ï¼šCï¼‰
  const ax = faceSize / 2,        ay = marginY;
  const bx = (faceSize - side) / 2, by = marginY + h;
  const cx = (faceSize + side) / 2, cy = marginY + h;


  for(let py=0; py<faceSize; py++){
    for(let px=0; px<faceSize; px++){
      const {inside,u,v,w} = pointInTri(px+0.5, py+0.5, ax,ay, bx,by, cx,cy);
      if(!inside) continue;

      const [dx,dy,dz] = baryToDir(u,v,w, A,B,C);
      const {lat, lon} = dirToLonLat(dx,dy,dz);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      const c = bilinearInterpolateEquirect(equirectData, ex, ey, ew, eh);

      const idx = (py*faceSize + px)*4;
      data[idx  ] = c[0];
      data[idx+1] = c[1];
      data[idx+2] = c[2];
      data[idx+3] = c[3];
    }
  }
  ctx.putImageData(img,0,0);
  return canvas;
}

function convertEquirectToIcosahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const equirectData = tctx.getImageData(0, 0, ew, eh).data;

  const {V,F} = icosahedronData();
  const faces = [];
  F.forEach((tri, i)=>{
    const A = V[tri[0]], B = V[tri[1]], C = V[tri[2]];
    const canvas = renderIcosaFace(equirectData, ew, eh, A,B,C, faceSize);
    faces.push({ name:`tri_${i}`, canvas });
  });
  return faces;
}






/* ============================= åˆ‡é ‚äºŒåé¢ä½“ï¼ˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼‰ ============================= */
function edgeKey(a,b){ return (a<b) ? `${a}_${b}` : `${b}_${a}`; }

function slerpLikeNormalize(A,B,t){
  const x = (1-t)*A[0] + t*B[0];
  const y = (1-t)*A[1] + t*B[1];
  const z = (1-t)*A[2] + t*B[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

function cross(X,Y){ return [X[1]*Y[2]-X[2]*Y[1], X[2]*Y[0]-X[0]*Y[2], X[0]*Y[1]-X[1]*Y[0]]; }
function add(X,Y){ return [X[0]+Y[0], X[1]+Y[1], X[2]+Y[2]]; }

function truncatedIcosahedronData(t=1/3){
  const {V,F} = icosahedronData();

  // å…¨ã‚¨ãƒƒã‚¸åé›†
  const edgeMap = new Map();
  F.forEach((tri, fi)=>{
    for(let k=0;k<3;k++){
      const a = tri[k], b = tri[(k+1)%3];
      const key = edgeKey(a,b);
      if(!edgeMap.has(key)) edgeMap.set(key, {a: Math.min(a,b), b: Math.max(a,b), faces: new Set()});
      edgeMap.get(key).faces.add(fi);
    }
  });

  // ç«¯ç‚¹å´åˆ‡é ‚ç‚¹ï¼ˆæœ‰å‘ï¼‰
  const Epoints = new Map();
  edgeMap.forEach(({a,b})=>{
    const A = V[a], B = V[b];
    Epoints.set(`${a}_${b}`, slerpLikeNormalize(A,B,t));
    Epoints.set(`${b}_${a}`, slerpLikeNormalize(B,A,t));
  });

  // äº”è§’ï¼šå„å…ƒé ‚ç‚¹aã®å‘¨ã‚Šï¼ˆ12æšï¼‰
  const pentagons = [];
  for(let a=0; a<V.length; a++){
    const connected = [];
    edgeMap.forEach(({a:ea,b:eb})=>{
      if(ea===a) connected.push(eb);
      else if(eb===a) connected.push(ea);
    });
    const pts = connected.map(b => Epoints.get(`${a}_${b}`));
    const n = V[a];
    const tmp = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
    // u = normalize(tmp Ã— n)
    let ux = tmp[1]*n[2] - tmp[2]*n[1];
    let uy = tmp[2]*n[0] - tmp[0]*n[2];
    let uz = tmp[0]*n[1] - tmp[1]*n[0];
    let invu = 1/Math.hypot(ux,uy,uz);
    const u = [ux*invu, uy*invu, uz*invu];
    // v = n Ã— u
    const vx = n[1]*u[2] - n[2]*u[1];
    const vy = n[2]*u[0] - n[0]*u[2];
    const vz = n[0]*u[1] - n[1]*u[0];
    const v = [vx,vy,vz];

    const withAng = pts.map(p=>{
      const ang = Math.atan2( p[0]*v[0]+p[1]*v[1]+p[2]*v[2], p[0]*u[0]+p[1]*u[1]+p[2]*u[2] );
      return {p, ang};
    }).sort((a,b)=>a.ang-b.ang);

    pentagons.push(withAng.map(o=>o.p));
  }

  // å…­è§’ï¼šå„å…ƒä¸‰è§’é¢ï¼ˆ20æšï¼‰
  const hexagons = [];
  F.forEach(([a,b,c])=>{
    const Pab = Epoints.get(`${a}_${b}`);
    const Pba = Epoints.get(`${b}_${a}`);
    const Pbc = Epoints.get(`${b}_${c}`);
    const Pcb = Epoints.get(`${c}_${b}`);
    const Pca = Epoints.get(`${c}_${a}`);
    const Pac = Epoints.get(`${a}_${c}`);

    const A=V[a], B=V[b], C=V[c];
    let n = add(add(cross(A,B), cross(B,C)), cross(C,A));
    const inv = 1/Math.hypot(n[0],n[1],n[2]); n = [n[0]*inv, n[1]*inv, n[2]*inv];

    const tmp = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
    let ux = tmp[1]*n[2] - tmp[2]*n[1];
    let uy = tmp[2]*n[0] - tmp[0]*n[2];
    let uz = tmp[0]*n[1] - tmp[1]*n[0];
    let invu = 1/Math.hypot(ux,uy,uz);
    const u = [ux*invu, uy*invu, uz*invu];
    const vx = n[1]*u[2] - n[2]*u[1];
    const vy = n[2]*u[0] - n[0]*u[2];
    const vz = n[0]*u[1] - n[1]*u[0];
    const v = [vx,vy,vz];

    const pts = [Pab,Pba,Pbc,Pcb,Pca,Pac];
    const withAng = pts.map(p=>{
      const ang = Math.atan2( p[0]*v[0]+p[1]*v[1]+p[2]*v[2], p[0]*u[0]+p[1]*u[1]+p[2]*u[2] );
      return {p, ang};
    }).sort((a,b)=>a.ang-b.ang);

    hexagons.push(withAng.map(o=>o.p));
  });

  return { pentagons, hexagons };
}

/* ============================= é¢å¹³é¢ãƒ™ãƒ¼ã‚¹ã®æç”»ï¼ˆæŠ•å½±ï¼‰ ============================= */
// é¢æ³•ç·šï¼ˆNewellé¢¨ï¼‰
function faceNormalOfPolygon(poly3D){
  let nx=0, ny=0, nz=0;
  const n = poly3D.length;
  for(let i=0;i<n;i++){
    const a = poly3D[i];
    const b = poly3D[(i+1)%n];
    nx += a[1]*b[2]-a[2]*b[1];
    ny += a[2]*b[0]-a[0]*b[2];
    nz += a[0]*b[1]-a[1]*b[0];
  }
  const inv = 1/Math.hypot(nx,ny,nz);
  return [nx*inv, ny*inv, nz*inv];
}

// nã«ç›´äº¤ã™ã‚‹åŸºåº•(u,v)
function basisUVfromNormal(n){
  const t = Math.abs(n[0])<0.9 ? [1,0,0] : [0,1,0];
  let ux = t[1]*n[2]-t[2]*n[1];
  let uy = t[2]*n[0]-t[0]*n[2];
  let uz = t[0]*n[1]-t[1]*n[0];
  const invu = 1/Math.hypot(ux,uy,uz);
  const u=[ux*invu, uy*invu, uz*invu];
  const vx = n[1]*u[2]-n[2]*u[1];
  const vy = n[2]*u[0]-n[0]*u[2];
  const vz = n[0]*u[1]-n[1]*u[0];
  const v=[vx,vy,vz];
  return {u,v};
}

// 3Dé ‚ç‚¹åˆ—ã‚’(u,v)å¹³é¢ã¸æ­£å°„å½±
function projectPolyToPlane2D(poly3D, u, v){
  return poly3D.map(p=> [ p[0]*u[0]+p[1]*u[1]+p[2]*u[2],
                           p[0]*v[0]+p[1]*v[1]+p[2]*v[2] ]);
}

// 2Dãƒãƒªã‚´ãƒ³AABB
function bounds2D(poly2D){
  let minx=+Infinity,miny=+Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const [x,y] of poly2D){
    if(x<minx) minx=x; if(x>maxx) maxx=x;
    if(y<miny) miny=y; if(y>maxy) maxy=y;
  }
  return {minx, miny, maxx, maxy};
}

// å‡¸å¤šè§’å½¢å†…åˆ¤å®šï¼ˆCCWæƒ³å®šï¼‰
function pointInConvexPoly(px,py, poly){
  const n=poly.length;
  let sign=0;
  for(let i=0;i<n;i++){
    const [ax,ay]=poly[i], [bx,by]=poly[(i+1)%n];
    const cross = (bx-ax)*(py-ay) - (by-ay)*(px-ax);
    if (cross!==0){
      const s = cross>0? 1:-1;
      if(sign===0) sign=s;
      else if(s!==sign) return false;
    }
  }
  return true;
}

// 2Dä¸‰è§’å½¢ï¼šå†…/å¤–ï¼‹ãƒãƒªã‚»ãƒ³
function pointInTri2D(px,py, ax,ay, bx,by, cx,cy, eps=-1e-6){
  const v0x=bx-ax, v0y=by-ay;
  const v1x=cx-ax, v1y=cy-ay;
  const v2x=px-ax, v2y=py-ay;
  const den = v0x*v1y - v0y*v1x;
  if (Math.abs(den) < 1e-12) return null;
  const v = (v2x*v1y - v2y*v1x)/den;
  const w = (v0x*v2y - v0y*v2x)/den;
  const u = 1 - v - w;
  if (u>=eps && v>=eps && w>=eps) return {u,v,w};
  return null;
}

// 2Då¤šè§’å½¢ã®ç¬¦å·ä»˜ãé¢ç©ï¼ˆCCWãªã‚‰æ­£ï¼‰
function signedArea2D(poly){
  let a=0;
  for(let i=0;i<poly.length;i++){
    const [x1,y1]=poly[i], [x2,y2]=poly[(i+1)%poly.length];
    a += x1*y2 - x2*y1;
  }
  return 0.5*a;
}

// é¢å¹³é¢ã¸å¼µã£ã¦æç”»ï¼ˆé ‚ç‚¹0èµ·ç‚¹ã®ä¸‰è§’ãƒ•ã‚¡ãƒ³ï¼‰ï¼ˆtargetEdgePx ãŒã‚ã‚Œã°è¾ºé•·ã‚’å„ªå…ˆï¼‰
function renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize, targetEdgePx=null){
  // 1) æ³•ç·šã¨åŸºåº•
  const n = faceNormalOfPolygon(poly3D);
  const {u,v} = basisUVfromNormal(n);

  // 2) 3Dâ†’2Dï¼ˆç”Ÿã®é¢å†…åº§æ¨™ï¼‰
  let poly2D = projectPolyToPlane2D(poly3D, u, v);

  // CCWä¿è¨¼
  if (signedArea2D(poly2D) < 0){
    poly2D.reverse();
    poly3D = [...poly3D].reverse();
  }

  // 3) ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ±ºã‚ã‚‹
  const rawBounds = bounds2D(poly2D);
  const rawW = rawBounds.maxx - rawBounds.minx;
  const rawH = rawBounds.maxy - rawBounds.miny;
  const fitScale = 0.9 * Math.min(faceSize/rawW, faceSize/rawH); // å¾“æ¥ã®ã€Œæ ã«ãƒ•ã‚£ãƒƒãƒˆã€

  let scale = fitScale;
  if (targetEdgePx != null){
    // â€œè¾ºé•·å„ªå…ˆâ€ã‚¹ã‚±ãƒ¼ãƒ«ï¼š rawã®å¹³å‡è¾ºé•·ã‚’ targetEdgePx ã«åˆã‚ã›ã‚‹
    const rawEdge = avgEdgeLen2D(poly2D);
    const edgeScale = targetEdgePx / rawEdge;
    // ãŸã ã—ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã¯ã¿å‡ºã™å ´åˆã¯ãƒ•ã‚£ãƒƒãƒˆä¸Šé™ã§æŠ‘ãˆã‚‹
    scale = Math.min(edgeScale, fitScale);
  }

  // 4) ã‚¹ã‚±ãƒ¼ãƒ«ï¼†ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°
  const cx = (rawBounds.minx + rawBounds.maxx)/2;
  const cy = (rawBounds.miny + rawBounds.maxy)/2;
  const P2 = poly2D.map(([x,y])=> [ (x-cx)*scale + faceSize/2, (y-cy)*scale + faceSize/2 ]);

  // 5) æç”»ï¼ˆå¾“æ¥åŒæ§˜ï¼‰
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  const xs = P2.map(p=>p[0]), ys = P2.map(p=>p[1]);
  const bbx0 = Math.max(0, Math.floor(Math.min(...xs)));
  const bbx1 = Math.min(faceSize-1, Math.ceil (Math.max(...xs)));
  const bby0 = Math.max(0, Math.floor(Math.min(...ys)));
  const bby1 = Math.min(faceSize-1, Math.ceil (Math.max(...ys)));

  for(let py=bby0; py<=bby1; py++){
    for(let px=bbx0; px<=bbx1; px++){
      if(!pointInConvexPoly(px+0.5, py+0.5, P2)) continue;

      let color = null;
      for(let i=1;i<P2.length-1;i++){
        const A=P2[0], B=P2[i], C=P2[i+1];
        const bc = pointInTri2D(px+0.5, py+0.5, A[0],A[1], B[0],B[1], C[0],C[1]);
        if(!bc) continue;

        const A3 = poly3D[0], B3 = poly3D[i], C3 = poly3D[i+1];
        let X = bc.u*A3[0] + bc.v*B3[0] + bc.w*C3[0];
        let Y = bc.u*A3[1] + bc.v*B3[1] + bc.w*C3[1];
        let Z = bc.u*A3[2] + bc.v*B3[2] + bc.w*C3[2];
        const inv = 1/Math.hypot(X,Y,Z);
        const dx = X*inv, dy = Y*inv, dz = Z*inv;

        const {lat,lon} = dirToLonLat(dx,dy,dz);
        const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
        const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
        color = bilinearInterpolateEquirect(eData, ex, ey, ew, eh);
        break;
      }
      if(color){
        const idx = (py*faceSize + px)*4;
        data[idx  ] = color[0];
        data[idx+1] = color[1];
        data[idx+2] = color[2];
        data[idx+3] = color[3];
      }
    }
  }
  ctx.putImageData(img,0,0);
  return canvas;
}


/* ============================= æ­£å…­é¢ä½“ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ï¼‰ ============================= */
// ã‚­ãƒ¥ãƒ¼ãƒ–ã®å„é¢ã«ãŠã‘ã‚‹ (u,v)âˆˆ[-1,1]Ã—[-1,1] â†’ æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ« dir ã‚’è¿”ã™
// å³æ‰‹ç³»ã§ y=ä¸Š, x=å³, z=å‰(+Z) ã‚’æƒ³å®šï¼ˆequirectã¯ atan2(x,z) ã‚’ä½¿ç”¨ï¼‰
function cubeUVToDir(face, u, v){
  // vã¯ç”»åƒåº§æ¨™ã‹ã‚‰ä¸ŠãŒæ­£ã«ãªã‚‹ã‚ˆã†ã«å¤‰æ›æ¸ˆã¿ã‚’æ¸¡ã™å‰æ
  // æ…£ç”¨ã®ã²ã¨ã¤ã®å–ã‚Šå›ã—ï¼šPX/NX/PY/NY/PZ/NZ
  switch(face){
    case 'px': return normalize([ 1,  v, -u ]);
    case 'nx': return normalize([-1,  v,  u ]);
    case 'py': return normalize([ u,  1,  v ]);
    case 'ny': return normalize([ u, -1, -v ]);
    case 'pz': return normalize([ u,  v,  1 ]);
    case 'nz': return normalize([-u,  v, -1 ]);
  }
  function normalize([x,y,z]){
    const inv = 1/Math.hypot(x,y,z);
    return [x*inv,y*inv,z*inv];
  }
}

function renderCubeFace(eData, ew, eh, faceName, faceSize){
  const canvas = document.createElement('canvas');
  canvas.width = faceSize; canvas.height = faceSize;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(faceSize, faceSize);
  const data = img.data;

  for(let py=0; py<faceSize; py++){
    // ç”»åƒåº§æ¨™â†’vï¼ˆä¸Šï¼‹ï¼‰: v = 1 - 2*(y+0.5)/N
    const v = 1 - 2*((py + 0.5)/faceSize);
    for(let px=0; px<faceSize; px++){
      // ç”»åƒåº§æ¨™â†’uï¼ˆå³ï¼‹ï¼‰
      const u = 2*((px + 0.5)/faceSize) - 1;

      const [dx,dy,dz] = cubeUVToDir(faceName, u, v);
      const {lat, lon} = dirToLonLat(dx,dy,dz);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      const c = bilinearInterpolateEquirect(eData, ex, ey, ew, eh);

      const idx = (py*faceSize + px)*4;
      data[idx  ] = c[0];
      data[idx+1] = c[1];
      data[idx+2] = c[2];
      data[idx+3] = c[3];
    }
  }
  ctx.putImageData(img,0,0);
  return canvas;
}

function convertEquirectToCube(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const order = ['px','nx','py','ny','pz','nz'];
  const names = {
    px:'px(+X)', nx:'nx(-X)', py:'py(+Y)', ny:'ny(-Y)', pz:'pz(+Z)', nz:'nz(-Z)'
  };
  const faces = [];
  order.forEach(f=>{


// 20250906+ for Cubeå±•é–‹ã«ç‰¹å®šã«äºŒé¢ã®ã¿å·¦å³åè»¢ã—ã¦90åº¦cw, ucwã™ã‚‹
let canvas = renderCubeFace(eData, ew, eh, f, faceSize);

// â˜…ç´™ã®å±•é–‹å›³å‘ã‘ã®é¢å‘ãèª¿æ•´ï¼š
//  - ny(-Y) ã¯ã€Œå·¦å³åè»¢ â†’ æ™‚è¨ˆå›ã‚Š90Â°ã€
//  - py(+Y) ã¯ã€Œå·¦å³åè»¢ â†’ åæ™‚è¨ˆå›ã‚Š90Â°ã€
if (f === 'ny'){
  canvas = flipHThenRotate90(canvas, 'cw');
} else if (f === 'py'){
  canvas = flipHThenRotate90(canvas, 'ccw');
}

    
    faces.push({name: names[f], canvas});
  });
  return faces;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆåˆ‡é ‚äºŒåé¢ä½“ï¼‰ ============================= */
function convertEquirectToTruncatedIcosahedron(equirectImage, faceSize, t=1/3){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {pentagons, hexagons} = truncatedIcosahedronData(t);

  // ---- å…­è§’å½¢ã®åŸºæº–è¾ºé•·ï¼ˆpxï¼‰ã‚’æ±ºã‚ã‚‹ ----
  // ä»£è¡¨ã¨ã—ã¦ hexagons[0] ã‚’é¢å†…æŠ•å½±ã—ã¦ã€"ãƒ•ã‚£ãƒƒãƒˆæç”»"ã§ã®å¹³å‡è¾ºé•·ã‚’æ±‚ã‚ã‚‹
  (function ensureHexExists(){
    if(!hexagons.length) throw new Error('hexagons not found');
  })();

  // æŠ•å½±ã ã‘ã—ã¦ fitScale * rawEdge ã‚’è¨ˆç®—ï¼ˆæç”»ã¯ã—ãªã„ï¼‰
  function projectedAvgEdgeLenIfFitted(poly3D){
    const n = faceNormalOfPolygon(poly3D);
    const {u,v} = basisUVfromNormal(n);
    const raw2 = projectPolyToPlane2D(poly3D, u, v);
    if (signedArea2D(raw2) < 0) raw2.reverse();
    const {minx,miny,maxx,maxy} = bounds2D(raw2);
    const rawW = maxx-minx, rawH = maxy-miny;
    const fitScale = 0.9 * Math.min(faceSize/rawW, faceSize/rawH);
    return avgEdgeLen2D(raw2) * fitScale;
  }
  const hexEdgePx = projectedAvgEdgeLenIfFitted(hexagons[0]);

  // ---- æç”»ï¼šå…­è§’å½¢ï¼ˆåŸºæº–ã©ãŠã‚Šï¼ãƒ•ã‚£ãƒƒãƒˆï¼‰ï¼äº”è§’å½¢ï¼ˆè¾ºé•·åˆã‚ã›ï¼‰ ----
  const faces = [];

  // äº”è§’å½¢ï¼ˆè¾ºé•·ã‚’ hexEdgePx ã«åˆã‚ã›ã‚‹ï¼å¿…è¦ãªã‚‰ç¸®å°ï¼‰
  pentagons.forEach((poly, i)=>{
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly, faceSize, /*targetEdgePx*/ hexEdgePx);
    faces.push({name:`pent_${String(i).padStart(2,'0')}`, kind:'P', canvas, poly3:poly});
  });

  // å…­è§’å½¢ï¼ˆå¾“æ¥ã©ãŠã‚Šãƒ•ã‚£ãƒƒãƒˆã€‚â€»å¿…è¦ãªã‚‰åŒã˜ target ã‚’æ¸¡ã—ã¦ã‚‚OKï¼‰
  hexagons.forEach((poly, i)=>{
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly, faceSize, /*targetEdgePx*/ null);
    faces.push({name:`hex_${String(i).padStart(2,'0')}`, kind:'H', canvas, poly3:poly});
  });

  return faces;
}

/* ============================= å¤‰æ›ã‚¨ãƒ³ãƒˆãƒªï¼ˆæ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼‰ ============================= */
function convertEquirectToRhombicuboctahedron(equirectImage, faceSize){
  const ew = equirectImage.width, eh = equirectImage.height;
  const tmp = document.createElement('canvas');
  tmp.width = ew; tmp.height = eh;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(equirectImage, 0, 0);
  const eData = tctx.getImageData(0, 0, ew, eh).data;

  const {V, triangles, squares} = rhombicuboctahedronData();
  const faces = [];

  // ä¸‰è§’å½¢é¢ï¼ˆ8å€‹ï¼‰
  triangles.forEach((tri, i)=>{
    const A = V[tri[0]], B = V[tri[1]], C = V[tri[2]];
    const canvas = renderIcosaFace(eData, ew, eh, A, B, C, faceSize);
    faces.push({name:`tri_${String(i).padStart(2,'0')}`, canvas});
  });

  // æ­£æ–¹å½¢é¢ï¼ˆ18å€‹ï¼‰
  squares.forEach((quad, i)=>{
    const poly3D = quad.map(idx => V[idx]);
    const canvas = renderPolyFacePlanar(eData, ew, eh, poly3D, faceSize);
    faces.push({name:`sq_${String(i).padStart(2,'0')}`, canvas});
  });

  return faces;
}

/* ============================= UI ãƒ­ã‚¸ãƒƒã‚¯ ============================= */
const el = {
  uploadArea: document.getElementById('uploadArea'),
  fileInput: document.getElementById('fileInput'),
  inputInfo: document.getElementById('inputInfo'),
  polyType: document.getElementById('polyType'),
  faceSize: document.getElementById('faceSize'),
  truncRow: document.getElementById('truncRow'),
  truncRange: document.getElementById('truncRange'),
  truncNumber: document.getElementById('truncNumber'),
  runBtn: document.getElementById('runBtn'),
  clearBtn: document.getElementById('clearBtn'),
  fmt: document.getElementById('fmt'),
  qualityRange: document.getElementById('qualityRange'),
  qualityLabel: document.getElementById('qualityLabel'),
  prefix: document.getElementById('prefix'),
  faces: document.getElementById('faces'),
  dlAllBtn: document.getElementById('dlAllBtn'),
  gridBtn: document.getElementById('gridBtn'),
  gridCanvas: document.getElementById('gridCanvas'),
  gridWrap: document.getElementById('gridWrap'),
  gridDownload: document.getElementById('gridDownload'),
  gridInfo: document.getElementById('gridInfo'),
  
    drawGuideBtn: document.getElementById('drawGuideBtn'),
    guideColor: document.getElementById('guideColor'),
    guideWidth: document.getElementById('guideWidth'),
  
};

let inputImage = null;
let originalImage = null; // å¸¸ã«ç”Ÿã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ä¿æŒ

let lastFaces = []; // {name, canvas}[]
let lastPoly = '';  // 'cube' | 'icosa' | 'truncated'

function loadImage(file){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
}

function setInputInfo(img){
  if(!img) { el.inputInfo.textContent = 'æœªèª­ã¿è¾¼ã¿'; return; }
  el.inputInfo.textContent = `å…¥åŠ›ï¼š${img.width} Ã— ${img.height} pxï¼ˆã‚¨ã‚¯ã‚¤æƒ³å®šï¼‰`;
}

function renderFacesToPanel(faces){
  el.faces.innerHTML = '';
  faces.forEach(({name, canvas})=>{
    const box = document.createElement('div');
    box.className = 'face';
    const p = document.createElement('p'); p.textContent = name;
    const save = document.createElement('button');
    save.className = 'btn ghost'; save.textContent = 'ä¿å­˜';
    save.onclick = ()=>{
      const mime = el.fmt.value;
      const quality = parseFloat(el.qualityRange.value);
      const url = (mime==='image/png') ? canvas.toDataURL(mime)
                                       : canvas.toDataURL(mime, quality);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${el.prefix.value}${name}.${extFromMime(mime)}`;
      a.click();
    };
    box.appendChild(p);
    box.appendChild(canvas);
    box.appendChild(save);
    el.faces.appendChild(box);
  });
}

function extFromMime(mime){
  if(mime==='image/png') return 'png';
  if(mime==='image/jpeg') return 'jpg';
  if(mime==='image/webp') return 'webp';
  return 'png';
}

// è¿½åŠ ï¼šCanvasâ†’Blob å¤‰æ›ï¼ˆawaitå¯¾å¿œï¼‰
async function canvasToBlob(canvas, mime, quality){
  return await new Promise(resolve => canvas.toBlob(resolve, mime, quality));
}

// è¿½åŠ ï¼šZIPåŒ–ã—ã¦1å›ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ä¿å­˜
async function zipAndDownload(fileEntries, zipBaseName){
  const zip = new JSZip();
  for (const { path, blob } of fileEntries){
    zip.file(path, blob);
  }
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${zipBaseName}.zip`;
  a.click();
  // ä¸€å®šæ™‚é–“å¾Œã«URLè§£æ”¾
  setTimeout(()=> URL.revokeObjectURL(url), 10000);
}

function buildGridAndPreview(faces){
  if(!faces.length) return;
  const N = faces.length;
  const cols = Math.ceil(Math.sqrt(N));
  const rows = Math.ceil(N / cols);

  const w = faces[0].canvas.width;
  const h = faces[0].canvas.height;

  const g = el.gridCanvas;
  g.width = cols * w;
  g.height = rows * h;

  const ctx = g.getContext('2d');
  ctx.clearRect(0,0,g.width,g.height);

  faces.forEach(({canvas}, i)=>{
    const r = Math.floor(i / cols);
    const c = i % cols;
    ctx.drawImage(canvas, c*w, r*h);
  });

  el.gridWrap.style.display = 'block';
  el.gridInfo.textContent = `ã‚¿ã‚¤ãƒ«ï¼š${g.width} Ã— ${g.height} pxï¼ˆ${cols}Ã—${rows}é¢ï¼‰`;

    el.gridDownload.style.display = 'inline-block';
    el.gridDownload.textContent = 'ã‚¿ã‚¤ãƒ«ã‚’ä¿å­˜';
    el.gridDownload.removeAttribute('onclick');
    
    el.gridDownload.onclick = async () => {
        const mime = el.fmt.value;
        const quality = parseFloat(el.qualityRange.value);
        const ext = extFromMime(mime);
        const prefix = el.prefix.value || '';
        const blob = await canvasToBlob(g, mime, quality);
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${prefix}${lastPoly}_grid.${ext}`;
        a.click();
        
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    };
}

// å˜ä½ãƒ™ã‚¯ãƒˆãƒ«é–“ã®SLERPï¼ˆç·šå½¢â†’æ­£è¦åŒ–ã®è¿‘ä¼¼ã§ã‚‚OKã ãŒã€ã“ã“ã¯æ»‘ã‚‰ã‹ã•é‡è¦–ï¼‰
function slerpUnit(A,B,t){
  // å†…ç©ã§è§’åº¦
  const dot = Math.max(-1, Math.min(1, A[0]*B[0] + A[1]*B[1] + A[2]*B[2]));
  const omega = Math.acos(dot);
  if (omega < 1e-6){
    return [A[0],A[1],A[2]];
  }
  const s1 = Math.sin((1-t)*omega)/Math.sin(omega);
  const s2 = Math.sin(t*omega)/Math.sin(omega);
  const x = s1*A[0] + s2*B[0];
  const y = s1*A[1] + s2*B[1];
  const z = s1*A[2] + s2*B[2];
  const inv = 1/Math.hypot(x,y,z);
  return [x*inv, y*inv, z*inv];
}

// è¾ºãƒªã‚¹ãƒˆï¼ˆå„è¾ºã¯ [A,B]ï¼šå˜ä½ãƒ™ã‚¯ãƒˆãƒ«ï¼‰ã‚’å¤šé¢ä½“ã‚¿ã‚¤ãƒ—ã‹ã‚‰åé›†
function gatherEdges(polyType, t=1/3){
  const edges = [];
  const addEdge = (a,b)=>{
    // æ–¹å‘ã«ä¾ã‚‰ãªã„ä¸€æ„åŒ–
    const key = a.map(v=>v.toFixed(6)).join(',') + '|' + b.map(v=>v.toFixed(6)).join(',');
    const keyR = b.map(v=>v.toFixed(6)).join(',') + '|' + a.map(v=>v.toFixed(6)).join(',');
    if (!addEdge._set) addEdge._set = new Set();
    if (addEdge._set.has(key) || addEdge._set.has(keyR)) return;
    addEdge._set.add(key); edges.push([a,b]);
  };

  if (polyType === 'icosa'){
    const {V,F} = icosahedronData();
    const ek = (i,j)=> i<j ? `${i}_${j}` : `${j}_${i}`;
    const seen = new Set();
    F.forEach(f=>{
      for(let k=0;k<3;k++){
        const a=f[k], b=f[(k+1)%3];
        const key = ek(a,b);
        if (seen.has(key)) continue;
        seen.add(key);
        addEdge(V[a], V[b]);
      }
    });
  } else if (polyType === 'cube'){
    // ç«‹æ–¹ä½“ã®8é ‚ç‚¹ï¼ˆæ­£è¦åŒ–ä¸è¦ï¼šÂ±1ï¼‰
    const V = [];
    [-1,1].forEach(x=>[-1,1].forEach(y=>[-1,1].forEach(z=>{
      const inv = 1/Math.hypot(x,y,z);
      V.push([x*inv,y*inv,z*inv]);
    })));
    // ã‚¨ãƒƒã‚¸ï¼ˆåº§æ¨™ãŒ1è»¸ã ã‘ç•°ãªã‚‹çµ„ã¿åˆã‚ã›ï¼‰
    const idx = (sx,sy,sz)=> (sx+1)/2*4 + (sy+1)/2*2 + (sz+1)/2;
    const signs=[-1,1];
    signs.forEach(x=>{
      signs.forEach(y=>{
        addEdge(V[idx(x,y,-1)], V[idx(x,y, 1)]);
      });
    });
    signs.forEach(x=>{
      signs.forEach(z=>{
        addEdge(V[idx(x,-1,z)], V[idx(x, 1,z)]);
      });
    });
    signs.forEach(y=>{
      signs.forEach(z=>{
        addEdge(V[idx(-1,y,z)], V[idx( 1,y,z)]);
      });
    });
  } else if (polyType === 'rhombicubocta') {
    // æ–œæ–¹ç«‹æ–¹å…«é¢ä½“ï¼šä¸‰è§’å½¢/æ­£æ–¹å½¢ãƒãƒªã‚´ãƒ³ã‹ã‚‰é€£ç¶šè¾º
    const {triangles, squares} = rhombicuboctahedronData();
    const polyEdges = (poly)=> poly.forEach((p,i)=>{
      const q = poly[(i+1)%poly.length];
      addEdge(V[p], V[q]);
    });
    const {V} = rhombicuboctahedronData();
    triangles.forEach(tri => tri.forEach((p,i)=>{
      const q = tri[(i+1)%3];
      addEdge(V[p], V[q]);
    }));
    squares.forEach(sq => sq.forEach((p,i)=>{
      const q = sq[(i+1)%4];
      addEdge(V[p], V[q]);
    }));
  } else {
    // åˆ‡é ‚äºŒåé¢ä½“ï¼šäº”è§’å½¢/å…­è§’å½¢ãƒãƒªã‚´ãƒ³ã‹ã‚‰é€£ç¶šè¾º
    const {pentagons, hexagons} = truncatedIcosahedronData(t);
    const polyEdges = (poly)=> poly.forEach((p,i)=>{
      const q = poly[(i+1)%poly.length];
      addEdge(p,q);
    });
    pentagons.forEach(polyEdges);
    hexagons.forEach(polyEdges);
  }
  return edges;
}

// è¾ºã‚’ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼(å…ƒç”»åƒ)ã¸æç”»ã—ã¦ä¿å­˜
async function drawGuideOnEquirectAndSave(img, polyType, opts){
  const {color='#ff2d55', width=2, t=1/3, samples=256, mime='image/png', quality=0.92, prefix='poly_'} = opts||{};
  const ew = img.width, eh = img.height;

  const cv = document.createElement('canvas');
  cv.width = ew; cv.height = eh;
  const ctx = cv.getContext('2d');
  ctx.drawImage(img, 0, 0);

  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  const edges = gatherEdges(polyType, t);

  edges.forEach(([A,B])=>{
    // ã‚µãƒ³ãƒ—ãƒ«åˆ—
    const pts = [];
    for(let i=0;i<=samples;i++){
      const tt = i/samples;
      const [x,y,z] = slerpUnit(A,B,tt);
      const {lat,lon} = dirToLonLat(x,y,z);
      const ex = ((lon + Math.PI) / (2*Math.PI)) * ew;
      const ey = ((Math.PI/2 - lat) / Math.PI) * eh;
      pts.push([ex,ey]);
    }
    // çµŒåº¦ã¾ãŸãï¼ˆÂ±Ï€ï¼‰ã®æŠ˜ã‚Œã‚’åˆ†å‰²ã—ã¦æã
    let seg = [pts[0]];
    for(let i=1;i<pts.length;i++){
      const [x0,_y0]=seg[seg.length-1];
      const [x1,_y1]=pts[i];
      if (Math.abs(x1 - x0) > ew*0.5){
        // ã‚¹ãƒ—ãƒªãƒƒãƒˆ
        ctx.beginPath();
        ctx.moveTo(seg[0][0], seg[0][1]);
        for(let k=1;k<seg.length;k++) ctx.lineTo(seg[k][0], seg[k][1]);
        ctx.stroke();
        seg = [pts[i]];
      }else{
        seg.push(pts[i]);
      }
    }
    if (seg.length>1){
      ctx.beginPath();
      ctx.moveTo(seg[0][0], seg[0][1]);
      for(let k=1;k<seg.length;k++) ctx.lineTo(seg[k][0], seg[k][1]);
      ctx.stroke();
    }
  });

  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  const blob = await new Promise(res=> cv.toBlob(res, mime, quality));
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const polyTag = (polyType==='cube'?'cube': polyType==='icosa'?'icosa':'truncated');
  a.download = `${prefix}${polyTag}_guide.${extFromMime(mime)}`;
  a.href = url; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 10000);
}




/* --------- ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰ --------- */



// ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆç¾¤ã®è¿‘ãã«è¿½è¨˜ï¼‰
document.getElementById('drawGuideBtn').addEventListener('click', async ()=>{
  if(!inputImage){ alert('å…ˆã«ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚'); return; }
  const type = el.polyType.value; // 'cube' | 'icosa' | 'truncated'
  const t = Math.max(0.15, Math.min(0.5, parseFloat(el.truncNumber?.value||'0.333'))); // åˆ‡é ‚ç”¨
  const mime = el.fmt.value;
  const quality = parseFloat(el.qualityRange.value);
  const prefix = el.prefix.value || '';
  const color = document.getElementById('guideColor').value;
  const width = Math.max(1, Math.min(8, parseInt(document.getElementById('guideWidth').value||'2',10)));
  await drawGuideOnEquirectAndSave(inputImage, type, {color, width, t, mime, quality, prefix});
});




el.uploadArea.addEventListener('dragover', e=>{
  e.preventDefault(); el.uploadArea.classList.add('dragover');
});
el.uploadArea.addEventListener('dragleave', e=>{
  el.uploadArea.classList.remove('dragover');
});
el.uploadArea.addEventListener('drop', async e=>{
  e.preventDefault(); el.uploadArea.classList.remove('dragover');
  const file = e.dataTransfer.files?.[0];
  if(!file) return;
  
 originalImage = await loadImage(file);// 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
 inputImage = originalImage;         // æ—¢å®šã¯å¸¸ã«ã‚ªãƒªã‚¸ãƒŠãƒ«
 setInputInfo(originalImage);
  
});
el.fileInput.addEventListener('change', async e=>{
  const file = e.target.files?.[0];
  if(!file) return;
 // 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
    // ã“ã“ã§ originalImage ã‚‚å¿…ãšæ›´æ–°ã—ã€inputImage ã‚’æƒãˆã‚‹
    originalImage = await loadImage(file);
    inputImage = originalImage;
setInputInfo(originalImage);
});

el.polyType.addEventListener('change', ()=>{
  const trunc = el.polyType.value === 'truncated';
  el.truncRow.style.display = trunc ? 'block' : 'none';
});

el.truncRange.addEventListener('input', ()=>{
  el.truncNumber.value = el.truncRange.value;
});
el.truncNumber.addEventListener('input', ()=>{
  el.truncRange.value = el.truncNumber.value;
});

el.qualityRange.addEventListener('input', ()=>{
  el.qualityLabel.textContent = Number(el.qualityRange.value).toFixed(2);
});

el.runBtn.addEventListener('click', ()=>{
if(!originalImage){ alert('å…ˆã«ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚'); return; }
  const faceSize = Math.max(32, Math.min(4096, parseInt(el.faceSize.value || '512',10)));
  const type = el.polyType.value;


// â˜…è¦ä»¶é€šã‚Šã®ç½®æ›ãƒ­ã‚¸ãƒƒã‚¯ï¼š 20250906+ for å¤šé‡é¢ä½“ã®é€†è»¢å‡¦ç†
//   cube       : ç½®ãæ›ãˆãšï¼ˆå¸¸ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’ä½¿ç”¨ï¼‰
//   icosa/truncated : å®Ÿè¡Œæ™‚ã«ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’å·¦å³åè»¢ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã§ inputImage ã‚’ç½®æ›ã—ã¦ã‹ã‚‰ç¶šè¡Œ
if (type === 'cube'){
  inputImage = originalImage; // ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã¾ã¾
} else if (type === 'icosa' || type === 'truncated'){
  inputImage = createHorizontallyFlippedCanvas(originalImage);
}




  let faces = [];
  if(type === 'cube'){
    faces = convertEquirectToCube(inputImage, faceSize);
  }else if(type === 'icosa'){
    faces = convertEquirectToIcosahedron(inputImage, faceSize);
  }else if(type === 'rhombicubocta'){
    faces = convertEquirectToRhombicuboctahedron(inputImage, faceSize);
  }else{
    const t = Math.max(0.15, Math.min(0.5, parseFloat(el.truncNumber.value||'0.333')));
    faces = convertEquirectToTruncatedIcosahedron(inputImage, faceSize, t);
  }
  
  lastFaces = faces;
  lastPoly = type;
  renderFacesToPanel(faces);
  el.gridWrap.style.display = 'none';
  el.gridDownload.style.display = 'none';
  el.gridInfo.textContent = '';
});

el.clearBtn.addEventListener('click', ()=>{
  lastFaces = [];
  el.faces.innerHTML = '';
  el.gridWrap.style.display = 'none';
  el.gridDownload.style.display = 'none';
  el.gridInfo.textContent = '';
});


// ZIPã§ã¾ã¨ã‚ã¦ä¿å­˜ã™ã‚‹ä»•æ§˜
el.dlAllBtn.addEventListener('click', async ()=>{
  if(!lastFaces.length){ alert('å…ˆã«å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚'); return; }

  const mime = el.fmt.value;
  const quality = parseFloat(el.qualityRange.value);
  const ext = extFromMime(mime);
  const prefix = el.prefix.value || '';

  // å€‹åˆ¥é¢ã‚’ZIPã¸è©°ã‚ã‚‹
  const files = [];
  for (const { name, canvas } of lastFaces){
    const blob = await canvasToBlob(canvas, mime, quality);
    files.push({ path: `${prefix}${name}.${ext}`, blob });
  }

  // ã‚‚ã—ã‚¿ã‚¤ãƒ«ãŒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¸ˆã¿ãªã‚‰ã€ã‚¿ã‚¤ãƒ«ã‚‚åŒæ¢±
  if (el.gridWrap.style.display === 'block'){
    const gBlob = await canvasToBlob(el.gridCanvas, mime, quality);
    files.push({ path: `${prefix}${lastPoly}_grid.${ext}`, blob: gBlob });
  }

  await zipAndDownload(files, `${prefix}${lastPoly}_all`);
});





el.gridBtn.addEventListener('click', ()=>{
  if(!lastFaces.length){ alert('å…ˆã«å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚'); return; }
  buildGridAndPreview(lastFaces);
});
</script>
</body>
</html>
